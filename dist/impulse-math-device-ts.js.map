{"version":3,"file":"impulse-math-device-ts.js","mappings":"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","sources":["webpack://impulse-math-device-ts/./build/Release/node_native_memory.node","webpack://impulse-math-device-ts/external node-commonjs \"path\"","webpack://impulse-math-device-ts/webpack/bootstrap","webpack://impulse-math-device-ts/webpack/runtime/compat get default export","webpack://impulse-math-device-ts/webpack/runtime/define property getters","webpack://impulse-math-device-ts/webpack/runtime/hasOwnProperty shorthand","webpack://impulse-math-device-ts/webpack/runtime/make namespace object","webpack://impulse-math-device-ts/webpack/runtime/node module decorator","webpack://impulse-math-device-ts/webpack/runtime/publicPath","webpack://impulse-math-device-ts/./src/typescript/Computation/utils.ts","webpack://impulse-math-device-ts/./src/typescript/Math/Calc.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcElement.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcScalar.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcColVector.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcRowVector.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcMatrix2D.ts","webpack://impulse-math-device-ts/./src/typescript/Math/CalcMatrix3D.ts","webpack://impulse-math-device-ts/external node-commonjs \"fs\"","webpack://impulse-math-device-ts/./src/typescript/Network/Network.ts","webpack://impulse-math-device-ts/./src/typescript/Network/NetworkRNN.ts","webpack://impulse-math-device-ts/./src/typescript/Network/NetworkLSTM.ts","webpack://impulse-math-device-ts/./src/typescript/types.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/AbstractBackpropagation.ts","webpack://impulse-math-device-ts/./src/typescript/Math/index.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/Backpropagation1Dto1D.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/Backpropagation3Dto1D.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/BackpropagationToMaxPool.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/BackpropagationToConv.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/BackpropagationToRecurrent.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/BackpropagationToLSTM.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Backpropagation/BackpropagationFactory.ts","webpack://impulse-math-device-ts/./src/typescript/NetworkBuilder/AbstractNetworkBuilder.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/AbstractLayer.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/AbstractLayer1D.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Softmax.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Logistic.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Tanh.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Relu.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Softplus.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/AbstractLayer3D.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Conv.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/FullyConnected.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/MaxPool.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/Recurrent.ts","webpack://impulse-math-device-ts/./src/typescript/Layer/LSTM.ts","webpack://impulse-math-device-ts/./src/typescript/NetworkBuilder/NetworkBuilder1D.ts","webpack://impulse-math-device-ts/./src/typescript/NetworkBuilder/NetworkBuilder3D.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/AbstractOptimizer.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerAdam.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerGradientDescent.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerAdagrad.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerMomentum.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerRMSProp.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/AbstractTrainer.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/MiniBatchTrainer.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Trainer.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Optimizer/OptimizerRNN.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/RNNTrainer.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Cost/AbstractCost.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Cost/MeanSquaredErrorCost.ts","webpack://impulse-math-device-ts/./src/typescript/Trainer/Cost/CrossEntropyCost.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/Dataset.ts","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetBuilder.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetVocabulary.ts","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetVocabularyBuilder.ts","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetBuilderSource/AbstractDatasetBuilderSource.ts","webpack://impulse-math-device-ts/external commonjs2 \"csvtojson\"","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetBuilderSource/DatasetBuilderSourceCSV.ts","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetVocabularyBuilderSource/DatasetVocabularyBuilderSourceTextFile.ts","webpack://impulse-math-device-ts/./src/typescript/DatasetBuilder/DatasetVocabularyBuilderSource/AbstractDatasetVocabularyBuilderSource.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/AbstractDatasetModifier.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/Callback.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/MinMaxScaling.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/MissingData.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/Shuffle.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/Category.ts","webpack://impulse-math-device-ts/./src/typescript/Dataset/DatasetModifier/Split.ts","webpack://impulse-math-device-ts/./src/typescript/main.ts"],"sourcesContent":["\ntry {\n  process.dlopen(module, require(\"path\").join(__dirname, __webpack_public_path__, \"8c0d713d94b87197578f9913475daeeb.node\"));\n} catch (error) {\n  throw new Error('node-loader:\\n' + error);\n}\n","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"\";","import nodenative from \"../../../build/Release/node_native_memory.node\";\n\ntype Device = any;\n\nlet currentDevice: Device = new nodenative.Device.CPU();\n\nexport const setDevice = (device: Device): void => {\n  currentDevice = device;\n};\n\nexport const getDevice = (): Device => {\n  return currentDevice;\n};\n","import { CalcElement } from \"./CalcElement\";\nimport { getDevice } from \"../Computation\";\n\nexport class Calc {\n  private _result: Array<CalcElement> | null = null;\n  private _params: Array<CalcElement> | null = null;\n\n  public static get() {\n    return new Calc();\n  }\n\n  public setResult(result: Array<CalcElement>) {\n    this._result = result;\n    return this;\n  }\n\n  public setParams(params: Array<CalcElement>) {\n    this._params = params;\n    return this;\n  }\n\n  public execSync(module: string, kernel: string) {\n    this.exec(module, kernel)(this._params, this._result);\n    return this;\n  }\n\n  /**\n   * Note: This function is not truly asynchronous. The underlying native addon\n   * does not support asynchronous execution.\n   */\n  public execAsync(module: string, kernel: string): Promise<Calc> {\n    return new Promise((resolve) => {\n      this.exec(module, kernel, true)(this._params, this._result).then(() => {\n        resolve(this);\n      });\n    });\n  }\n\n  private exec(module: string, kernel: string, async = false) {\n    try {\n      const device = getDevice();\n      const m = device.loadModule(module);\n      const fn = m.loadFunction(kernel);\n\n      return (input: Array<CalcElement> | null = null, output: Array<CalcElement> | null = null) => {\n        return fn.execute(\n          (input || []).map((m) => m.getMemory()),\n          (output || []).map((m) => m.getMemory()),\n          async\n        );\n      };\n    } catch (e) {\n      console.error(e);\n      return () => {};\n    }\n  }\n}\n","import { getDevice } from \"../Computation\";\nimport { CalcScalar } from \"./CalcScalar\";\nimport { Calc } from \"./Calc\";\nimport { CalcMatrix2D } from \"./CalcMatrix2D\";\n\nexport class CalcElement {\n  private _dims: Array<number> = [];\n  protected _allocated = false;\n  protected _memory: any = null;\n\n  constructor(width = 1, height = 1, depth = 1) {\n    this._dims = [width, height, depth];\n  }\n\n  public dims(): Array<number> {\n    return this._dims;\n  }\n\n  public rows(): number {\n    return this._dims[0];\n  }\n\n  public cols(): number {\n    return this._dims[1];\n  }\n\n  public depth(): number {\n    return this._dims[2];\n  }\n\n  public count(): number {\n    const [width, height, depth] = this._dims;\n\n    return width * height * depth;\n  }\n\n  public resize(width = 1, height = 1, depth = 1) {\n    this._dims = [width, height, depth];\n    this.allocate();\n    return this;\n  }\n\n  public allocate() {\n    const device = getDevice();\n    this._memory = device.alloc(this.count());\n    this._memory.setWidth(this.rows());\n    this._memory.setHeight(this.cols());\n    this._memory.setDepth(this.depth());\n    this._allocated = true;\n\n    return this;\n  }\n\n  public set(arr: Array<number>) {\n    this._memory.set(new Float64Array(arr));\n    return this;\n  }\n\n  public get() {\n    return this._memory.get();\n  }\n\n  public isScalar() {\n    return false;\n  }\n\n  public isRowVector() {\n    return false;\n  }\n\n  public isColVector() {\n    return false;\n  }\n\n  public isMatrix2D() {\n    return false;\n  }\n\n  public isMatrix3D() {\n    return false;\n  }\n\n  public setZeros() {\n    this.calcSync((calc) => {\n      calc.setZeros();\n    });\n    return this;\n  }\n\n  public setRandom(number: number) {\n    this.calcSync((calc) => {\n      calc.setRandom(number);\n    });\n    return this;\n  }\n\n  public setMax(number: number) {\n    this.calcSync((calc) => {\n      calc.setMax(number);\n    });\n    return this;\n  }\n\n  public setMin(number: number) {\n    this.calcSync((calc) => {\n      calc.setMin(number);\n    });\n    return this;\n  }\n\n  public reluBackpropagation(number: number) {\n    this.calcSync((calc) => {\n      calc.reluBackpropagation();\n    });\n    return this;\n  }\n  public pow(number: number) {\n    return this.calcSync((calc) => {\n      return calc.pow(number);\n    });\n  }\n  public sum() {\n    return this.calcSync((calc) => {\n      return calc.sum();\n    });\n  }\n  public reluForwardPropagation() {\n    this.calcSync((calc) => {\n      calc.reluForwardPropagation();\n    });\n    return this;\n  }\n\n  private getCalcSandbox(async = false) {\n    const that = this;\n    return {\n      sum: () => {\n        const result = new CalcScalar().allocate();\n        return that._call(\"algebra\", \"algebra_sum\", async)([that, result])(result);\n      },\n      setZeros: () => {\n        return that._call(\"matrix\", \"matrix_set_zeros\", async)([that])(that);\n      },\n      setRandom: (number: number) => {\n        const nb = new CalcScalar().allocate().set([number]);\n        return that._call(\"matrix\", \"matrix_set_random\", async)([that, nb])(that);\n      },\n    };\n  }\n\n  protected _call(module: string, kernel: string, async: boolean) {\n    return (params, result) => {\n      const calc = Calc.get().setResult(result).setParams(params);\n      return (result) => {\n        if (async) {\n          return new Promise((resolve) => {\n            calc.execAsync(module, kernel).then(() => {\n              resolve(result);\n            });\n          })\n        } else {\n          calc.execSync(module, kernel);\n          return result;\n        }\n      }\n    };\n  }\n\n  public calcSync(callback) {\n    return callback(this.getCalcSandbox(false));\n  }\n\n  public calcAsync(callback) {\n    return new Promise((resolve, reject) => {\n      try {\n        const result = callback(this.getCalcSandbox(true));\n        resolve(result);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  public getMemory() {\n    return this._memory;\n  }\n\n  [Symbol.dispose]() {\n    this._memory.free();\n  }\n\n  public destroy() {\n    this._memory.free();\n    this._dims = [0, 0, 0];\n    this._allocated = false;\n  }\n\n  public copyFrom(other: CalcElement) {\n    if (!this._allocated) {\n      const device = getDevice();\n      this._memory = device.alloc(other.count());\n      this._allocated = true;\n    }\n    this._memory.setWidth(other.rows());\n    this._memory.setHeight(other.cols());\n    this._memory.setDepth(other.depth());\n    this._memory.copyFrom(other.getMemory());\n    this._dims = other.dims();\n    return this;\n  }\n}\n","import { CalcElement } from \"./CalcElement\";\n\nexport class CalcScalar extends CalcElement {\n  constructor() {\n    super(1);\n  }\n\n  public isScalar() {\n    return true;\n  }\n}\n","import { CalcElement } from \"./CalcElement\";\n\nexport class CalcColVector extends CalcElement {\n  constructor(cols = 1) {\n    super(1, cols);\n  }\n\n  public isColVector() {\n    return true;\n  }\n\n  public static fromMemory(memory, cols: number) {\n    const result = new CalcColVector(cols);\n    result._memory = memory;\n    result._allocated = true;\n    return result;\n  }\n}\n","import { CalcElement } from \"./CalcElement\";\nimport { CalcColVector } from \"./CalcColVector\";\n\nexport class CalcRowVector extends CalcElement {\n  constructor(rows = 1) {\n    super(rows);\n  }\n\n  public isRowVector() {\n    return true;\n  }\n\n  public transpose() {\n    const result = CalcColVector.fromMemory(this.getMemory().clone(), this.rows());\n    return result;\n  }\n}\n","import { CalcElement } from \"./CalcElement\";\nimport { CalcRowVector } from \"./CalcRowVector\";\nimport { CalcScalar } from \"./CalcScalar\";\n\nexport class CalcMatrix2D extends CalcElement {\n  constructor(rows = 1, cols = 1) {\n    super(rows, cols);\n  }\n\n  public isMatrix2D() {\n    return true;\n  }\n\n  public row(index: Number): CalcMatrix2D {\n    const result = new CalcMatrix2D(1, this.cols()).allocate();\n    return this._call(\n      \"matrix\",\n      \"matrix_row\",\n      false\n    )([this, new CalcScalar().allocate().set(new Float64Array([index])), result])(result);\n  }\n\n  public col(index: Number): CalcMatrix2D {\n    const result = new CalcMatrix2D(this.rows(), 1).allocate();\n    return this._call(\n      \"matrix\",\n      \"matrix_col\",\n      false\n    )([this, new CalcScalar().allocate().set(new Float64Array([index])), result])(result);\n  }\n\n  public maxCoeff(): number {\n    return this.calcSync((calc) => {\n      return calc.maxCoeff();\n    });\n  }\n\n  public dot(m: CalcMatrix2D) {\n    return this.calcSync((calc) => {\n      return calc.dot(m);\n    });\n  }\n\n  public add(m: CalcMatrix2D) {\n    return this.calcSync((calc) => {\n      return calc.add(m);\n    });\n  }\n\n  public replicate(rows: number, cols: number) {\n    return this.calcSync((calc) => {\n      return calc.replicate(rows, cols);\n    });\n  }\n\n  public transpose(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.transpose();\n    });\n  }\n\n  public logisticForwardPropagation(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.logisticForwardPropagation();\n    });\n  }\n\n  public logisticBackwardPropagation(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.logisticBackwardPropagation();\n    });\n  }\n\n  public pow(number: number): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.pow(number);\n    });\n  }\n\n  public log(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.log();\n    });\n  }\n\n  public multiply(number: number | CalcMatrix2D): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.multiply(number);\n    });\n  }\n  public minusOne(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.minusOne();\n    });\n  }\n  public conjugate(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.conjugate();\n    });\n  }\n  public divide(mOrNumber: number | CalcMatrix2D): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.divide(mOrNumber);\n    });\n  }\n  public subtract(m: CalcMatrix2D): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.subtract(m);\n    });\n  }\n  public rowwiseSum(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.rowwiseSum();\n    });\n  }\n  public softmax(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.softmax();\n    });\n  }\n  public fraction(num: number): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.fraction(num);\n    });\n  }\n  public tanh(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.tanh();\n    });\n  }\n  public tanhDerivative(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.tanhDerivative();\n    });\n  }\n  public logMinusOne(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.logMinusOne();\n    });\n  }\n  public sqrt(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.sqrt();\n    });\n  }\n  public block(offset: number, batch: number, start: number, end: number): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.block(offset, batch, start, end);\n    });\n  }\n  public softmaxDerivative(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.softmaxDerivative();\n    });\n  }\n  public min(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.min();\n    });\n  }\n  public max(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.max();\n    });\n  }\n  public minMax(): CalcMatrix2D {\n    return this.calcSync((calc) => {\n      return calc.minMax();\n    });\n  }\n\n  protected getCalcSandbox(async = false) {\n    const baseSandbox = super.getCalcSandbox(async);\n    const that = this;\n    return {\n      ...baseSandbox,\n      block(offset: number, batch: number, start: number, end: number): CalcMatrix2D {\n        const result = new CalcMatrix2D(end - start, batch).allocate();\n        const _offset = new CalcScalar().allocate().set([offset]);\n        const _batch = new CalcScalar().allocate().set([batch]);\n        const _start = new CalcScalar().allocate().set([start]);\n        const _end = new CalcScalar().allocate().set([end]);\n        return that._call(\"matrix\", \"matrix_block\", async)([that, _offset, _batch, _start, _end, result])(result);\n      },\n      pow: (number: number) => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_pow\", async)([that, new CalcScalar().allocate().set([number]), result])(result);\n      },\n      fraction: (number: number) => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_fraction\", async)([that, new CalcScalar().allocate().set([number]), result])(result);\n      },\n      softmax: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_softmax\", async)([that, result])(result);\n      },\n      sqrt: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_sqrt\", async)([that, result])(result);\n      },\n      tanh: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_tanh\", async)([that, result])(result);\n      },\n      tanhDerivative: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_tanh_derivative\", async)([that, result])(result);\n      },\n      softmaxDerivative: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_softmax_derivative\", async)([that, result])(result);\n      },\n      rowwiseSum: () => {\n        const result = new CalcMatrix2D(this.rows(), 1).allocate();\n        return that._call(\"algebra\", \"algebra_rowwise_sum\", async)([that, result])(result);\n      },\n      multiply: (m: CalcMatrix2D | number) => {\n        if (typeof m === \"number\") {\n          const _m = new CalcScalar().allocate().set([m]);\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n          return that._call(\"algebra\", \"algebra_multiply_number\", async)([that, _m, result])(result);\n        } else {\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n          return that._call(\"algebra\", \"algebra_multiply\", async)([that, m, result])(result);\n        }\n      },\n      log: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_log\", async)([that, result])(result);\n      },\n      divide: (mOrNumber: number | CalcMatrix2D) => {\n        if (typeof mOrNumber === \"number\") {\n          const num = new CalcScalar().allocate().set([mOrNumber]);\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n          return that._call(\"algebra\", \"algebra_divide_number\", async)([that, num, result])(result);\n        } else {\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n          return that._call(\"algebra\", \"algebra_divide_matrix\", async)([that, mOrNumber, result])(result);\n        }\n      },\n      dot: (m: CalcMatrix2D) => {\n        const result = new CalcMatrix2D(this.rows(), m.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_dot\", async)([that, m, result])(result);\n      },\n      add: (m: CalcMatrix2D | number) => {\n        if (typeof m === \"number\") {\n          const num = new CalcScalar().allocate().set([m]);\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate(); // Corrected dimensions for dot product result\n          return that._call(\"algebra\", \"algebra_add_number\", async)([that, num, result])(result);\n        } else {\n          const result = new CalcMatrix2D(this.rows(), this.cols()).allocate(); // Corrected dimensions for dot product result\n          return that._call(\"algebra\", \"algebra_add_matrix\", async)([that, m, result])(result);\n        }\n      },\n      subtract: (m: CalcMatrix2D) => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate(); // Corrected dimensions for dot product result\n        return that._call(\"algebra\", \"algebra_subtract\", async)([that, m, result])(result);\n      },\n      transpose: () => {\n        const result = new CalcMatrix2D(this.cols(), this.rows()).allocate(); // Corrected dimensions for dot product result\n        return that._call(\"matrix\", \"matrix_transpose\", async)([that, result])(result);\n      },\n      logMinusOne: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate(); // Corrected dimensions for dot product result\n        return that._call(\"algebra\", \"algebra_log_minus_one\", async)([that, result])(result);\n      },\n      minusOne: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate(); // Corrected dimensions for dot product result\n        return that._call(\"algebra\", \"algebra_minus_one\", async)([that, result])(result);\n      },\n      replicate: (rows: number, cols: number) => {\n        const _rows = this.rows() * rows;\n        const _cols = this.cols() * cols;\n        const result = new CalcMatrix2D(_rows, _cols).allocate();\n        const __rows = new CalcScalar().allocate().set([rows]);\n        const __cols = new CalcScalar().allocate().set([cols]);\n        return that._call(\"algebra\", \"algebra_replicate_matrix\", async)([that, __rows, __cols, result])(result);\n      },\n      logisticForwardPropagation: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_logistic_forward_propagation\", async)([that, result])(result);\n      },\n      conjugate: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_conjugate\", async)([that, result])(result);\n      },\n      logisticBackwardPropagation: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_logistic_backward_propagation\", async)([that, result])(result);\n      },\n      reluBackpropagation: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_reluBackpropagation\", async)([that, result])(result);\n      },\n      maxCoeff: () => {\n        const result = new CalcScalar().allocate();\n        return that._call(\"algebra\", \"algebra_max_coeff\", async)([that, result])(result);\n      },\n      setMin: (number: number) => {\n        const nb = new CalcScalar().allocate().set([number]);\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"matrix\", \"matrix_set_min\", async)([that, nb, result])(result);\n      },\n      setMax: (number: number) => {\n        const nb = new CalcScalar().allocate().set([number]);\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"matrix\", \"matrix_set_max\", async)([that, nb, result])(result);\n      },\n      min: () => {\n        const result = new CalcScalar().allocate();\n        return that._call(\"matrix\", \"matrix_min\", async)([that, result])(result);\n      },\n      max: () => {\n        const result = new CalcScalar().allocate();\n        return that._call(\"matrix\", \"matrix_max\", async)([that, result])(result);\n      },\n      minMax: () => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        return that._call(\"algebra\", \"algebra_min_max\", async)([that, result])(result);\n      },\n      img2col: (filterSize, stride, padding) => {\n        const result = new CalcMatrix2D(this.rows(), this.cols()).allocate();\n        const params = new CalcRowVector(3).allocate().set([filterSize, stride, padding]);\n        return that._call(\"algebra\", \"algebra_img2col\", async)([that, params, result])(result);\n      },\n    };\n  }\n\n  public clone() {\n    const clone = new CalcMatrix2D(this.rows(), this.cols());\n    clone.copyFrom(this);\n    return clone;\n  }\n}\n","import { CalcElement } from \"./CalcElement\";\n\nexport class CalcMatrix3D extends CalcElement {\n  constructor(rows = 1, cols = 1, depth = 1) {\n    super(rows, cols, depth);\n  }\n\n  public isMatrix3D() {\n    return true;\n  }\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","import { Dimension, Layers } from \"../types\";\nimport { CalcMatrix2D } from \"../Math\";\nimport * as fs from \"fs\";\n\nclass Network {\n  private readonly dimensions: Dimension | null = null;\n  private size = 0;\n  private layers: Layers[] = [];\n\n  constructor(dimensions: Dimension) {\n    this.dimensions = dimensions;\n  }\n\n  addLayer(layer: Layers): Network {\n    this.size++;\n    this.layers.push(layer);\n\n    return this;\n  }\n\n  getLayers(): Layers[] {\n    return this.layers;\n  }\n\n  getLastLayer(): Layers {\n    return this.layers[this.layers.length - 1];\n  }\n\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    let output = input;\n\n    this.layers.forEach((layer: Layers) => {\n      output = layer.forward(output);\n    });\n\n    return output;\n  }\n\n  forwardAsync(input: CalcMatrix2D): Promise<CalcMatrix2D> {\n    return new Promise((resolve) => {\n      let output = input.clone();\n      let l = 0;\n      const next = () => {\n        return this.layers[l].forwardAsync(output).then((out) => {\n          output.destroy();\n          output = out;\n          if (l < this.layers.length - 1) {\n            l++;\n            next();\n          } else {\n            resolve(output);\n          }\n        })\n      };\n\n      next();\n    })\n  }\n\n  backward(X: CalcMatrix2D, regularization: number, sigma: CalcMatrix2D): void {\n    const m = X.cols();\n    let currentSigma = sigma;\n\n    for (let i = this.layers.length - 1; i >= 0; i -= 1) {\n      const layer = this.layers[i];\n      currentSigma = layer.getBackPropagation().propagate(X, m, regularization, layer, currentSigma);\n    }\n  }\n\n  save(path: string): Promise<string> {\n    const resultJSON = {\n      dimensions: this.dimensions,\n      layers: [],\n    };\n\n    this.layers.forEach((layer: Layers) => {\n      resultJSON.layers.push({\n        type: layer.getType(),\n        size: layer.getSize(),\n        weights: {\n          W: layer.W.get(),\n          b: layer.b.get(),\n        },\n      });\n    });\n\n    const result = JSON.stringify(resultJSON);\n\n    return new Promise((resolve, reject) => {\n      fs.writeFile(path, result, (err) => {\n        if (err) {\n          console.error(err);\n          reject();\n        }\n        resolve(result);\n      });\n    });\n  }\n}\n\nexport { Network };\nexport default Network;\n","\nexport class NetworkRNN {\n  /*private readonly dimensions: Dimension | null = null;W\n  private size = 0;\n  private layers: LayersRNN[] = [];\n\n  constructor(dimensions: Dimension) {\n    this.dimensions = dimensions;\n  }\n\n  addLayer(layer: LayersRNN): NetworkRNN {\n    this.size++;\n    this.layers.push(layer);\n\n    return this;\n  }\n\n  getLayers(): LayersRNN[] {\n    return this.layers;\n  }\n\n  sample(dataset: DatasetVocabulary, length = 50) {\n    const Waa = this.layers[0].wA;\n    const Wax = this.layers[0].wX;\n    const Wya = this.layers[0].wY;\n    const by = this.layers[0].wBY;\n    const b = this.layers[0].wB;\n    const indices = [];\n    const charIndices = dataset.getCharIndices();\n    const newLineCharacter = charIndices[\"\\n\"];\n    const chars = dataset.getChars();\n\n    let x = new Matrix(this.dimensions[1], 1).setZeros();\n    let aPrev = new Matrix(this.dimensions[0], 1).setRandom(this.dimensions[1]);\n\n    let idx = -1;\n    let counter = 0;\n\n    while (idx != newLineCharacter && counter != length) {\n      const a = Wax.dot(x).add(Waa.dot(aPrev)).add(b).tanh();\n      const z = Wya.dot(a).add(by);\n      const y = z.softmax();\n\n      idx = charIndices[chars[y.colMaxCoeffIndex(0)]];\n      x = new Matrix(this.dimensions[1], 1).setZeros();\n      const maxIndex = y.colMaxCoeffIndex(0);\n\n      x.data[maxIndex][0] = 1;\n\n      indices.push(idx);\n      aPrev = a;\n\n      counter += 1;\n    }\n\n    if (counter === 50) {\n      indices.push(newLineCharacter);\n    }\n\n    return indices\n      .map((i) => {\n        return chars[i];\n      })\n      .join(\"\");\n  }\n\n  forward(X: Matrix, Y: Matrix, aPrev: Matrix): Object {\n    const { aNext, y, p, loss } = this.layers[0].forward(X.transpose(), Y, aPrev);\n    return { aNext, y, p, loss };\n  }\n\n  backward(X: Matrix, Y: Matrix, A: Matrix, aNext: Matrix): void {\n    this.layers[0].backward(X, Y, A, aNext);\n  }\n\n  getDimensions(): Dimension {\n    return this.dimensions;\n  }\n\n  save(path: string): Promise<string> {\n    const resultJSON = {\n      dimensions: this.dimensions,\n      layers: [],\n    };\n\n    this.layers.forEach((layer: Layers) => {\n      resultJSON.layers.push({\n        type: layer.getType(),\n        size: layer.getSize(),\n        weights: {\n          wX: layer.wX.data,\n          wA: layer.wA.data,\n          wY: layer.wY.data,\n          wB: layer.wB.data,\n          wBY: layer.wBY.data,\n        },\n      });\n    });\n\n    const result = JSON.stringify(resultJSON);\n\n    return new Promise((resolve, reject) => {\n      fs.writeFile(path, result, (err) => {\n        if (err) {\n          console.error(err);\n          reject();\n        }\n        resolve(result);\n      });\n    });\n  }*/\n}\n","import { Dimension, Layers, LayersLSTM } from \"../types\";\n\nexport class NetworkLSTM {\n  /*private readonly dimensions: Dimension | null = null;\n  private size = 0;\n  private layers: LayersLSTM[] = [];\n\n  constructor(dimensions: Dimension) {\n    this.dimensions = dimensions;\n  }\n\n  addLayer(layer: LayersLSTM): NetworkLSTM {\n    this.size++;\n    this.layers.push(layer);\n\n    return this;\n  }\n\n  getLayers(): LayersLSTM[] {\n    return this.layers;\n  }\n\n  loss(vocabularySize: number, sequenceLength: number): number {\n    return -Math.log(1 / vocabularySize) * sequenceLength;\n  }\n\n  sample(charIndices: Object) {}\n\n  forward(X: Matrix[], a0: Matrix): Matrix[] {\n    const nX = X.length;\n    const m = X[0].rows;\n    const tX = X[0].cols;\n    const nY = this.layers[0].Wy.rows;\n    const nA = this.layers[0].Wy.cols;\n\n    const a = new Array(nA).map(() => {\n      return new Matrix(m, tX).setZeros();\n    });\n    const c = new Array(nA).map(() => {\n      return new Matrix(m, tX).setZeros();\n    });\n    const y = new Array(nY).map(() => {\n      return new Matrix(m, tX).setZeros();\n    });\n\n    let aNext = a0;\n    let cNext = new Matrix(nA, m).setZeros();\n\n    for (let t = 0; t < tX; t += 1) {\n      const dataInput = [];\n      X.forEach((m: Matrix, i) => {\n        dataInput[i] = [];\n        for (let row = 0; row < m.rows; row += 1) {\n          dataInput[i].push(m.data[row][t]);\n        }\n      });\n      const input = Matrix.from(dataInput);\n      const [_aNext, _cNext, _yt] = this.layers[0].forward(input, aNext, cNext);\n    }\n  }\n\n  backward(da: Matrix[]): void {\n    const na = da.length;\n    const m = da[0].rows;\n    const tx = da[0].cols;\n    const nx = this.layers[0].x1.rows;\n\n    for (let t = tx - 1; t >= 0; t -= 1) {\n      //this.layers[0].backward(_da, dcPrevT);\n    }\n  }\n\n  /*save(path: string): Promise<string> {\n    const resultJSON = {\n      dimensions: this.dimensions,\n      layers: [],\n    };\n\n    this.layers.forEach((layer: Layers) => {\n      resultJSON.layers.push({\n        type: layer.getType(),\n        size: layer.getSize(),\n        weights: {\n          W: layer.W.data,\n          b: layer.b.data,\n        },\n      });\n    });\n\n    const result = JSON.stringify(resultJSON);\n\n    return new Promise((resolve, reject) => {\n      fs.writeFile(path, result, (err) => {\n        if (err) {\n          console.error(err);\n          reject();\n        }\n        resolve(result);\n      });\n    });\n  }*/\n}\n","import { SoftmaxLayer, LogisticLayer, TanhLayer, ReluLayer, SoftplusLayer, AbstractLayer } from \"./Layer\";\nimport { ConvLayer } from \"./Layer/\";\nimport { MaxPoolLayer } from \"./Layer/\";\nimport { FullyConnectedLayer } from \"./Layer/\";\nimport { PurelinLayer } from \"./Layer\";\nimport { AbstractLayer3D } from \"./Layer/AbstractLayer3D\";\nimport { AbstractLayer1D } from \"./Layer/AbstractLayer1D\";\nimport { RecurrentLayer } from \"./Layer\";\nimport { LSTMLayer } from \"./Layer\";\n\nexport type Dimension = [number] | [number, number, number];\n\nexport enum LayerType {\n  logistic = \"logistic\",\n  softmax = \"softmax\",\n  tanh = \"tanh\",\n  relu = \"relu\",\n  softplus = \"softplus\",\n  conv = \"conv\",\n  maxpool = \"maxpool\",\n  fullyconnected = \"fullyconnected\",\n  purelin = \"purelin\",\n  rnnlayer = \"rnnlayer\",\n  lstm = \"lstm\"\n}\n\nexport type Layers =\n  | LogisticLayer\n  | SoftmaxLayer\n  | TanhLayer\n  | ReluLayer\n  | SoftplusLayer\n  | ConvLayer\n  | MaxPoolLayer\n  | FullyConnectedLayer\n  | PurelinLayer\n  | RecurrentLayer\n  | AbstractLayer3D\n  | AbstractLayer1D;\nexport type Layers1D = LogisticLayer | SoftmaxLayer | TanhLayer | ReluLayer | SoftplusLayer | PurelinLayer;\nexport type Layers3D = ConvLayer | MaxPoolLayer | FullyConnectedLayer | AbstractLayer3D;\nexport type LayersRNN = RecurrentLayer;\nexport type LayersLSTM = LSTMLayer;","import { Layers } from \"../../types\";\nimport { CalcMatrix2D } from \"../../Math\";\n\nexport abstract class AbstractBackPropagation {\n  protected layer: Layers | null = null;\n  protected previousLayer: Layers | null = null;\n\n  constructor(layer: Layers | null, previousLayer: Layers) {\n    this.layer = layer;\n    this.previousLayer = previousLayer;\n  }\n\n  abstract propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D,\n    previousSigma: CalcMatrix2D\n  ): CalcMatrix2D;\n}\n","import {Calc} from \"./Calc\";\nimport {CalcScalar} from \"./CalcScalar\"\nimport {CalcColVector} from \"./CalcColVector\";\nimport {CalcRowVector} from \"./CalcRowVector\"\nimport {CalcMatrix2D} from \"./CalcMatrix2D\";\nimport {CalcMatrix3D} from \"./CalcMatrix3D\"\n\nconst round = (num: number, decimalPlaces: number): number => {\n  return Math.round((num + 2.23e-16) * Math.pow(10, decimalPlaces)) / Math.pow(10, decimalPlaces);\n};\n\nexport {\n  Calc, CalcScalar, CalcMatrix2D, CalcColVector, CalcRowVector, CalcMatrix3D, round,\n};\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { Layers } from \"../../types\";\n\nexport class Backpropagation1Dto1D extends AbstractBackPropagation {\n  propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D\n  ): CalcMatrix2D {\n    const previousActivations = this.previousLayer !== null ? this.previousLayer.A : input;\n    const delta = sigma.dot(previousActivations.transpose().conjugate());\n    this.layer.gW = delta.divide(numberOfExamples).add(layer.W.multiply(regularization / numberOfExamples));\n    this.layer.gb = sigma.rowwiseSum().divide(numberOfExamples);\n\n    if (this.previousLayer !== null) {\n      // @ts-ignore\n      const result = this.layer.W.transpose().dot(sigma);\n      if (result.rows() !== previousActivations.rows() || result.cols() !== previousActivations.cols()) {\n        throw new Error(\n          `Dimension error 1. (${result.rows()}, ${result.cols()}) | (${previousActivations.rows()}, ${previousActivations.cols()})`\n        );\n      }\n      if (this.layer.gW.rows() !== this.layer.W.rows() || this.layer.gW.cols() !== this.layer.W.cols()) {\n        throw new Error(\n          `Dimension error 2. (${this.layer.gW.rows()}, ${this.layer.gW.cols()}) | (${this.layer.W.rows()}, ${this.layer.W.cols()})`\n        );\n      }\n      if (this.layer.gb.rows() !== this.layer.b.rows() || this.layer.gb.cols() !== this.layer.b.cols()) {\n        throw new Error(\n          `Dimension error 3. (${this.layer.gb.rows()}, ${this.layer.gb.cols()}) | (${this.layer.b.rows()}, ${this.layer.b.cols()})`\n        );\n      }\n      return result.multiply(this.layer.previousLayer.derivative(this.layer.previousLayer.A));\n    }\n    return new CalcMatrix2D();\n  }\n}\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { Layers } from \"../../types\";\n\nexport class Backpropagation3Dto1D extends AbstractBackPropagation {\n  propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D\n  ): CalcMatrix2D {\n    return sigma;\n  }\n}\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { Layers } from \"../../types\";\nimport { MaxPoolLayer } from \"../MaxPool\";\n\n/**\n * Implementuje wsteczn propagacj dla warstwy Max-Pooling.\n * Dziaa jak \"przecznik\", kierujc gradienty tylko do tych neuronw,\n * ktre miay maksymaln warto podczas przechodzenia w przd.\n */\nexport class BackpropagationToMaxPool extends AbstractBackPropagation {\n  propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D\n  ): CalcMatrix2D {\n    const maxPoolLayer = layer as MaxPoolLayer;\n    // @ts-ignore\n    const { switches, inputShape } = maxPoolLayer.cache;\n    const [inputHeight, inputWidth, inputDepth, batchSize] = inputShape;\n\n    // Stwrz macierz gradientu wejciowego wypenion zerami\n    const dX = new CalcMatrix2D(inputHeight * inputWidth * inputDepth, batchSize).setZeros();\n    const dXData = dX.get();\n    const sigmaData = sigma.get();\n\n    let switchIndex = 0;\n    const outputSize = sigma.get().length;\n\n    // Rozprowad gradienty do odpowiednich miejsc\n    for (let i = 0; i < outputSize; i++) {\n        const maxIndex = switches[switchIndex++];\n        dXData[maxIndex] += sigmaData[i];\n    }\n\n    dX.set(dXData);\n\n    // Przekszta gradient do ksztatu oczekiwanego przez poprzedni warstw\n    return dX.reshape(inputHeight * inputWidth * inputDepth, batchSize);\n  }\n}\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { Layers, Layers3D } from \"../../types\";\nimport {CalcMatrix2D} from '../../Math'\n\nexport class BackpropagationToConv extends AbstractBackPropagation {\n  /*protected previousLayer: Layers3D | null = null;\n\n  propagate(input: CalcMatrix2D, numberOfExamples: number, regularization: number, layer: Layers, sigma: CalcMatrix2D): Matrix {\n    const previousLayer = this.previousLayer;\n\n    if (previousLayer) {\n      const padding = previousLayer.getPadding();\n      const stride = previousLayer.getStride();\n      const filterSize = previousLayer.getFilterSize();\n      const outputWidth = previousLayer.getOutputWidth();\n      const outputHeight = previousLayer.getOutputHeight();\n      const outputDepth = previousLayer.getOutputDepth();\n      const inputWidth = previousLayer.getWidth();\n      const inputHeight = previousLayer.getHeight();\n      const inputDepth = previousLayer.getDepth();\n\n      const tmpResult = getComputation().execute(\n        \"fillZeros\",\n        new Matrix((inputWidth + 2 * padding) * (inputHeight + 2 * padding) * inputDepth, numberOfExamples)\n      ) as Matrix;\n\n      const result = new CalcMatrix2D(inputWidth * inputHeight * inputDepth, numberOfExamples);\n\n      previousLayer.gW = getComputation().execute(\"fillZeros\", previousLayer.gW) as Matrix;\n      previousLayer.gb = getComputation().execute(\"fillZeros\", previousLayer.gb) as Matrix;\n\n      for (let m = 0; m < numberOfExamples; m++) {\n        for (let c = 0; c < outputDepth; c++) {\n          for (let h = 0; h < outputHeight; h++) {\n            for (let w = 0; w < outputWidth; w++) {\n              const vertStart = stride * h;\n              const vertEnd = vertStart + filterSize;\n              const horizStart = stride * w;\n              const horizEnd = horizStart + filterSize;\n\n              // filter loop\n              for (let d = 0; d < inputDepth; d++) {\n                for (\n                  let y = 0, vertical = vertStart, verticalPad = -padding;\n                  y < filterSize;\n                  y++, vertical++, verticalPad++\n                ) {\n                  for (\n                    let x = 0, horizontal = horizStart, horizontalPad = -padding;\n                    x < filterSize;\n                    x++, horizontal++, horizontalPad++\n                  ) {\n                    if (previousLayer.W.data && tmpResult.data && sigma.data) {\n                      tmpResult.data[\n                        d * (inputWidth + 2 * padding) * (inputHeight + 2 * padding) +\n                          vertical * (inputWidth + 2 * padding) +\n                          horizontal\n                      ][m] +=\n                        previousLayer.W.data[c][d * filterSize * filterSize + y * filterSize + x] *\n                        sigma.data[c * outputWidth * outputHeight + h * outputWidth + w][m];\n                    }\n\n                    let z = 0;\n                    if (padding == 0) {\n                      if (previousLayer.Z.data) {\n                        z = previousLayer.Z.data[d * inputWidth * inputHeight + vertical * inputWidth + horizontal][m];\n                      }\n                    } else {\n                      if (\n                        verticalPad >= 0 &&\n                        horizontalPad >= 0 &&\n                        verticalPad < inputHeight &&\n                        horizontalPad < inputWidth\n                      ) {\n                        if (previousLayer.Z.data) {\n                          z =\n                            previousLayer.Z.data[\n                              d * inputWidth * inputHeight + verticalPad * inputWidth + horizontalPad\n                            ][m];\n                        }\n                      }\n                    }\n\n                    if (previousLayer.gW.data && sigma.data) {\n                      previousLayer.gW.data[c][d * filterSize * filterSize + y * filterSize + x] +=\n                        (z * sigma.data[c * (outputWidth * outputHeight) + h * outputWidth + w][m]) / numberOfExamples;\n                    }\n                  }\n                }\n              }\n\n              if (previousLayer.gb.data && sigma.data) {\n                previousLayer.gb.data[c][0] +=\n                  sigma.data[c * (outputWidth * outputHeight) + h * outputWidth + w][m] / numberOfExamples;\n              }\n            }\n          }\n        }\n\n        if (padding > 0) {\n          // unpad\n          for (let c = 0; c < inputDepth; c++) {\n            for (let h = -padding, y = 0; h < inputHeight + padding; h++, y++) {\n              for (let w = -padding, x = 0; w < inputWidth + padding; w++, x++) {\n                if (w >= 0 && h >= 0 && w < inputWidth && h < inputHeight && result.data && tmpResult.data) {\n                  result.data[c * inputWidth * inputHeight + h * inputWidth + w][m] =\n                    tmpResult.data[\n                      c * (inputWidth + 2 * padding) * (inputHeight + 2 * padding) + y * (inputWidth + 2 * padding) + x\n                    ][m];\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (padding > 0) {\n        return result;\n      }\n\n      return tmpResult;\n    }\n  }*/\n}\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { Layers } from \"../../types\";\nimport { RecurrentLayer } from \"../Recurrent\";\n\nexport class BackpropagationToRecurrent extends AbstractBackPropagation {\n  propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D\n  ): CalcMatrix2D {\n    const rnnLayer = layer as RecurrentLayer;\n    const { A, X } = rnnLayer.cache;\n    const sequenceLength = X.length;\n\n    // Inicjalizacja gradientu dla stanu ukrytego\n    let daNext = new CalcMatrix2D(rnnLayer.getWidth(), 1).setZeros();\n\n    // Ptla wsteczna po krokach czasowych (Backpropagation Through Time)\n    for (let t = sequenceLength - 1; t >= 0; t--) {\n      const dyt = sigma.col(t); // Gradient kosztu wzgldem wyjcia w kroku t\n\n      // 1. Oblicz gradienty dla wag wyjciowych (Wya, by)\n      rnnLayer.dWya = rnnLayer.dWya.add(dyt.dot(A[t + 1].transpose()));\n      rnnLayer.dby = rnnLayer.dby.add(dyt);\n\n      // 2. Oblicz gradient propagowany do stanu ukrytego\n      // da = dC/da<t> = (dC/dy<t> * dy<t>/da<t>) + da_next\n      const da = rnnLayer.Wya.transpose().dot(dyt).add(daNext);\n\n      // 3. Oblicz gradient dla funkcji aktywacji tanh\n      // dtanh = da<t> * (1 - a<t>^2)\n      const dtanh = da.multiply(rnnLayer.derivative(A[t + 1]));\n\n      // 4. Oblicz gradienty dla wag rekurencyjnych i wejciowych (Waa, Wax, ba)\n      rnnLayer.dWax = rnnLayer.dWax.add(dtanh.dot(X[t].transpose()));\n      rnnLayer.dWaa = rnnLayer.dWaa.add(dtanh.dot(A[t].transpose()));\n      rnnLayer.dba = rnnLayer.dba.add(dtanh);\n\n      // 5. Zaktualizuj gradient dla poprzedniego kroku czasowego\n      // da_next (dla kroku t-1) = Waa^T * dtanh\n      daNext = rnnLayer.Waa.transpose().dot(dtanh);\n    }\n\n    // Normalizacja gradientw i dodanie regularyzacji\n    const clipValue = 5; // Zapobieganie eksplodujcym gradientom\n    for (const d of [rnnLayer.dWax, rnnLayer.dWaa, rnnLayer.dWya, rnnLayer.dba, rnnLayer.dby]) {\n        d.clip(-clipValue, clipValue);\n    }\n    \n    // Zastosowanie normalizacji przez liczb przykadw (w tym przypadku 1, bo batching nie jest zaimplementowany)\n    // rnnLayer.dWax = rnnLayer.dWax.divide(numberOfExamples);\n    // ... etc. dla reszty\n\n    // Dodanie regularyzacji\n    rnnLayer.dWax = rnnLayer.dWax.add(rnnLayer.Wax.multiply(regularization));\n    rnnLayer.dWaa = rnnLayer.dWaa.add(rnnLayer.Waa.multiply(regularization));\n    rnnLayer.dWya = rnnLayer.dWya.add(rnnLayer.Wya.multiply(regularization));\n\n    // Warstwa rekurencyjna zazwyczaj nie propaguje bdu dalej w ten sposb.\n    // Zwracamy pust macierz, aby zatrzyma propagacj.\n    return new CalcMatrix2D();\n  }\n}\n","import { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { Layers } from \"../../types\";\nimport { LSTMLayer } from \"../LSTM\";\n\nexport class BackpropagationToLSTM extends AbstractBackPropagation {\n  propagate(\n    input: CalcMatrix2D,\n    numberOfExamples: number,\n    regularization: number,\n    layer: Layers,\n    sigma: CalcMatrix2D\n  ): CalcMatrix2D {\n    const lstmLayer = layer as LSTMLayer;\n    const { A, C, X, F, I, G, O } = lstmLayer.cache;\n    const sequenceLength = X.length;\n    const hiddenSize = lstmLayer.getWidth();\n\n    // Inicjalizacja gradientw propagowanych w czasie\n    let daNext = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    let dcNext = new CalcMatrix2D(hiddenSize, 1).setZeros();\n\n    // Ptla wsteczna po krokach czasowych (BPTT)\n    for (let t = sequenceLength - 1; t >= 0; t--) {\n      // Gradient dla stanu ukrytego a<t> = bd z wyjcia + bd z przyszoci\n      const da = sigma.col(t).add(daNext);\n\n      // --- Obliczanie gradientw dla kadej bramki ---\n\n      // Bramka wyjciowa (Output Gate)\n      const dot = da.multiply(C[t + 1].tanh());\n      const dZo = dot.multiply(O[t]).multiply(O[t].minusOne().multiply(-1)); // d(sigmoid)\n\n      // Stan komrki (Cell State)\n      const dc = da.multiply(O[t]).multiply(lstmLayer.derivative(C[t + 1])).add(dcNext);\n\n      // Bramka zapominania (Forget Gate)\n      const dft = dc.multiply(C[t]);\n      const dZf = dft.multiply(F[t]).multiply(F[t].minusOne().multiply(-1)); // d(sigmoid)\n\n      // Bramka wejciowa (Input Gate)\n      const dit = dc.multiply(G[t]);\n      const dZi = dit.multiply(I[t]).multiply(I[t].minusOne().multiply(-1)); // d(sigmoid)\n\n      // Bramka kandydujca (Candidate Gate)\n      const dgt = dc.multiply(I[t]);\n      const dZg = dgt.multiply(lstmLayer.derivative(G[t])); // d(tanh)\n\n      // --- Poczenie gradientw bramek i obliczenie gradientw wag ---\n\n      // Pocz gradienty bramek w jedn macierz [dZf, dZi, dZg, dZo]\n      const dZ = CalcMatrix2D.vstack([dZf, dZi, dZg, dZo]);\n\n      // Oblicz gradienty dla wag i biasw\n      lstmLayer.dW = lstmLayer.dW.add(dZ.dot(X[t].transpose()));\n      lstmLayer.dU = lstmLayer.dU.add(dZ.dot(A[t].transpose()));\n      lstmLayer.db = lstmLayer.db.add(dZ);\n\n      // --- Propagacja gradientw do poprzedniego kroku czasowego ---\n\n      // da_next (dla t-1) = U^T * dZ\n      daNext = lstmLayer.U.transpose().dot(dZ);\n      // dc_next (dla t-1) = dc * f<t>\n      dcNext = dc.multiply(F[t]);\n    }\n\n    // --- Finalizacja gradientw ---\n\n    // 1. Obcinanie gradientw (Gradient Clipping) - kluczowe dla stabilnoci LSTM\n    const clipValue = 5;\n    for (const d of [lstmLayer.dW, lstmLayer.dU, lstmLayer.db]) {\n      d.clip(-clipValue, clipValue);\n    }\n\n    // 2. Dodanie regularyzacji do wag\n    lstmLayer.dW = lstmLayer.dW.add(lstmLayer.W.multiply(regularization));\n    lstmLayer.dU = lstmLayer.dU.add(lstmLayer.U.multiply(regularization));\n\n    // Warstwa LSTM nie propaguje bdu dalej w standardowy sposb.\n    return new CalcMatrix2D();\n  }\n}\n","import { Layers, LayerType } from \"../../types\";\nimport { Backpropagation1Dto1D } from \"./Backpropagation1Dto1D\";\nimport { Backpropagation3Dto1D } from \"./Backpropagation3Dto1D\";\nimport { BackpropagationToMaxPool } from \"./BackpropagationToMaxPool\";\nimport { BackpropagationToConv } from \"./BackpropagationToConv\";\nimport { AbstractBackPropagation } from \"./AbstractBackpropagation\";\nimport { BackpropagationToRecurrent } from \"./BackpropagationToRecurrent\";\nimport { BackpropagationToLSTM } from \"./BackpropagationToLSTM\";\n\nexport class BackpropagationFactory {\n  static create(previousLayer: Layers, layer: Layers): AbstractBackPropagation | null {\n    // --- Reguy oparte na typie biecej warstwy ---\n    if (layer.getType() === LayerType.rnnlayer) {\n      return new BackpropagationToRecurrent(layer, previousLayer);\n    }\n    if (layer.getType() === LayerType.lstm) {\n      return new BackpropagationToLSTM(layer, previousLayer);\n    }\n    if (layer.getType() === LayerType.maxpool) {\n      return new BackpropagationToMaxPool(layer, previousLayer);\n    }\n    if (layer.getType() === LayerType.conv) {\n      return new BackpropagationToConv(layer, previousLayer);\n    }\n\n    // --- Reguy oparte na typie poprzedniej warstwy (jeli istniej) ---\n    if (previousLayer) {\n        if (previousLayer.is1D() || previousLayer.getType() == LayerType.fullyconnected) {\n            return new Backpropagation1Dto1D(layer, previousLayer);\n        }\n    } \n    // --- Domylne reguy ---\n    else {\n        if (layer.is1D()) {\n            return new Backpropagation1Dto1D(layer, previousLayer);\n        } else if (layer.is3D()) {\n            // Domylna obsuga dla warstw 3D, jeli adna inna regua nie pasuje\n            return new Backpropagation3Dto1D(layer, previousLayer);\n        }\n    }\n\n    return null;\n  }\n}\n","import { Dimension, Layers } from \"../types\";\nimport { Network, NetworkRNN, Networks } from \"../Network\";\nimport { BackpropagationFactory } from \"../Layer/Backpropagation/BackpropagationFactory\";\nimport { NetworkLSTM } from \"../Network/NetworkLSTM\";\nimport { DatasetVocabulary } from \"../Dataset/DatasetVocabulary\";\n\nabstract class AbstractNetworkBuilder {\n  protected dimensions: Dimension | null = null;\n  protected lastLayer: Layers | null = null;\n  protected network: Networks | null = null;\n\n  constructor(dimension: Dimension, type = \"DNN\") {\n    this.dimensions = dimension;\n\n    if (type === \"DNN\") {\n      this.network = new Network(this.dimensions);\n    } else if (type === \"RNN\") {\n      this.network = new NetworkRNN(this.dimensions);\n    } else if (type === \"LSTM\") {\n      this.network = new NetworkLSTM(this.dimensions);\n    }\n  }\n\n  createLayer(layerClass: Layers, callback: (layer: Layers) => void | null = null): AbstractNetworkBuilder {\n    // @ts-ignore\n    const layer: Layers = new layerClass();\n\n    if (typeof callback === \"function\") {\n      callback(layer);\n    }\n\n    if (this.lastLayer === null) {\n      this.firstLayerTransition(layer);\n    } else {\n      // @ts-ignore\n      layer.transition(this.lastLayer);\n    }\n\n    layer.configure();\n    layer.setBackPropagation(BackpropagationFactory.create(this.lastLayer, layer));\n\n    this.network.addLayer(layer);\n    this.lastLayer = layer;\n\n    return this;\n  }\n\n  getNetwork(): Networks | null {\n    return this.network;\n  }\n\n  abstract firstLayerTransition(layer: Layers): void;\n}\n\nexport { AbstractNetworkBuilder };\n","import { CalcMatrix2D } from \"../Math/CalcMatrix2D\";\nimport { Dimension, Layers } from \"../types\";\nimport { AbstractBackPropagation } from \"./Backpropagation/AbstractBackpropagation\";\n\nabstract class AbstractLayer {\n  protected width = 0;\n  protected height = 0;\n  protected depth = 0;\n  public previousLayer: Layers | null = null;\n  protected backPropagation: AbstractBackPropagation | null = null;\n\n  constructor() {}\n\n  setBackPropagation(backPropagation: AbstractBackPropagation): Layers {\n    this.backPropagation = backPropagation;\n    return this;\n  }\n\n  getBackPropagation(): AbstractBackPropagation | null {\n    return this.backPropagation;\n  }\n\n  setWidth(value: number): Layers {\n    this.width = value;\n    return this;\n  }\n\n  getWidth(): number {\n    return this.width;\n  }\n\n  setHeight(value: number): Layers {\n    this.height = value;\n    return this;\n  }\n\n  getHeight(): number {\n    return this.height;\n  }\n\n  setDepth(value: number): Layers {\n    this.depth = value;\n    return this;\n  }\n\n  getDepth(): number {\n    return this.depth;\n  }\n\n  abstract getOutputWidth(): number;\n\n  abstract getOutputHeight(): number;\n\n  abstract getOutputDepth(): number;\n\n  abstract configure(): void;\n\n  abstract is1D(): boolean;\n\n  abstract is3D(): boolean;\n\n  transition(previousLayer: Layers): Layers {\n    this.previousLayer = previousLayer;\n    return this;\n  }\n\n  abstract getSize(): Dimension | number;\n\n  abstract activation(value: CalcMatrix2D): CalcMatrix2D;\n\n  abstract activationAsync(value: CalcMatrix2D): Promise<CalcMatrix2D>;\n\n  abstract getType(): string;\n\n  abstract derivative(delta: CalcMatrix2D): CalcMatrix2D;\n\n  abstract penalty(): number;\n}\n\nexport { AbstractLayer };\n","import { AbstractLayer } from \"./AbstractLayer\";\nimport { Layers } from \"../types\";\nimport { CalcMatrix2D, CalcScalar } from \"../Math\";\n\nabstract class AbstractLayer1D extends AbstractLayer {\n  protected depth = 1;\n  public W: CalcMatrix2D;\n  public b: CalcMatrix2D;\n  public A: CalcMatrix2D;\n  public Z: CalcMatrix2D;\n  public gW: CalcMatrix2D;\n  public gb: CalcMatrix2D;\n  public vW: CalcMatrix2D;\n  public sW: CalcMatrix2D;\n  public vb: CalcMatrix2D;\n  public sb: CalcMatrix2D;\n  public dW: CalcMatrix2D;\n  public db: CalcMatrix2D;\n  public dZ: CalcMatrix2D;\n\n  constructor() {\n    super();\n    this.W = new CalcMatrix2D();\n    this.b = new CalcMatrix2D();\n    this.A = new CalcMatrix2D();\n    this.Z = new CalcMatrix2D();\n    this.gW = new CalcMatrix2D();\n    this.gb = new CalcMatrix2D();\n    this.vW = new CalcMatrix2D();\n    this.vb = new CalcMatrix2D();\n    this.sW = new CalcMatrix2D();\n    this.sb = new CalcMatrix2D();\n    this.dW = new CalcMatrix2D();\n    this.db = new CalcMatrix2D();\n  }\n\n  configure(): void {\n    this.W.resize(this.getHeight(), this.getWidth());\n    this.W.setRandom(this.previousLayer ? (this.previousLayer.getHeight() as number) : this.getHeight());\n\n    this.b.resize(this.getHeight(), 1);\n    this.b.setRandom(this.previousLayer ? (this.previousLayer.getHeight() as number) : this.getHeight());\n\n    this.gW.resize(this.getHeight(), this.getWidth());\n    this.gW.setZeros();\n\n    this.gb.resize(this.getHeight(), 1);\n    this.gb.setZeros();\n\n    this.sW.resize(this.getHeight(), this.getWidth());\n    this.sW.setZeros();\n\n    this.sb.resize(this.getHeight(), 1);\n    this.sb.setZeros();\n\n    this.vW.resize(this.getHeight(), this.getWidth());\n    this.vW.setZeros();\n\n    this.vb.resize(this.getHeight(), 1);\n    this.vb.setZeros();\n\n    this.dW.resize(this.getHeight(), this.getWidth());\n    this.dW.setZeros();\n\n    this.db.resize(this.getHeight(), 1);\n    this.db.setZeros();\n  }\n\n  forward(input: CalcMatrix2D): Promise<CalcMatrix2D> {\n    this.Z = this.W.dot(input).add(this.b.replicate(1, input.cols()));\n    this.A = this.activation(this.Z);\n    return this.A;\n  }\n\n  forwardAsync(input: CalcMatrix2D): Promise<CalcMatrix2D> {\n    return new Promise((resolve) => {\n        Promise.all([\n          this.W.calcAsync((calc) => {\n            return calc.dot(input);\n          }),\n          this.b.calcAsync((calc) => {\n            return calc.replicate(1, input.cols());\n          })\n        ]).then(([dot, replicate]) => {\n          dot.calcAsync((calc) => {\n            return calc.add(replicate)\n          }).then((added) => {\n            this.Z.copyFrom(added);\n            this.activationAsync(this.Z).then((activation) => {\n              this.A.copyFrom(activation);\n\n              dot.destroy();\n              replicate.destroy();\n              added.destroy();\n              activation.destroy();\n\n              resolve(this.A);\n          })\n        })\n      });\n    })\n  }\n\n  is1D(): boolean {\n    return true;\n  }\n\n  is3D(): boolean {\n    return false;\n  }\n\n  transition(previousLayer: Layers): AbstractLayer1D {\n    if (previousLayer.is1D()) {\n      this.setWidth(previousLayer.getSize() as number);\n    } else if (previousLayer.is3D()) {\n      this.setWidth(previousLayer.getOutputWidth() * previousLayer.getOutputHeight() * previousLayer.getOutputDepth());\n    }\n\n    super.transition(previousLayer);\n\n    return this;\n  }\n\n  setSize(value: number): AbstractLayer1D {\n    this.setHeight(value as number);\n\n    return this;\n  }\n\n  getSize(): number {\n    return this.height;\n  }\n\n  getOutputWidth(): number {\n    return this.width;\n  }\n\n  getOutputHeight(): number {\n    return this.height;\n  }\n\n  getOutputDepth(): number {\n    return 1;\n  }\n\n  penalty(): CalcScalar {\n    return this.W.pow(2).sum();\n  }\n}\n\nexport { AbstractLayer1D };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\nclass SoftmaxLayer extends AbstractLayer1D {\n  activationAsync(value: CalcMatrix2D): Promise<CalcMatrix2D> {\n    throw new Error(\"Method not implemented.\");\n  }\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.softmax();\n  }\n\n  getType(): LayerType {\n    return LayerType.softmax;\n  }\n\n  derivative(delta: CalcMatrix2D): CalcMatrix2D {\n    return delta.softmaxDerivative();\n  }\n}\n\nexport { SoftmaxLayer };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\nclass LogisticLayer extends AbstractLayer1D {\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.logisticForwardPropagation();\n  }\n\n  activationAsync(m: CalcMatrix2D): Promise<CalcMatrix2D> {\n    return new Promise((resolve) => {\n      m.calcAsync((calc) => {\n        calc.logisticForwardPropagation().then((a) => {\n          resolve(a);\n        })\n      })\n    })\n  }\n\n  getType(): LayerType {\n    return LayerType.logistic;\n  }\n\n  derivative(delta: CalcMatrix2D): CalcMatrix2D {\n    return delta.logisticBackwardPropagation();\n  }\n}\n\nexport { LogisticLayer };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\nclass TanhLayer extends AbstractLayer1D {\n  activationAsync(value: CalcMatrix2D): Promise<CalcMatrix2D> {\n    throw new Error(\"Method not implemented.\");\n  }\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.tanh();\n  }\n\n  getType(): LayerType {\n    return LayerType.tanh;\n  }\n\n  derivative(sigma: CalcMatrix2D): CalcMatrix2D {\n    return sigma.tanhDerivative();\n  }\n}\n\nexport { TanhLayer };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\nclass ReluLayer extends AbstractLayer1D {\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.setMin(0.0);\n  }\n\n  activationAsync(m: CalcMatrix2D): Promise<CalcMatrix2D> {\n    return new Promise((resolve) => {\n      m.calcAsync((calc) => {\n        calc.setMin(0.0).then((a) => {\n          resolve(a);\n        })\n      })\n    })\n  }\n\n  getType(): LayerType {\n    return LayerType.relu;\n  }\n\n  derivative(delta: CalcMatrix2D) {\n    return delta.reluBackpropagation();\n  }\n}\n\nexport { ReluLayer };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\nclass SoftplusLayer extends AbstractLayer1D {\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.exp().add(1).log();\n  }\n\n  getType(): LayerType {\n    return LayerType.softplus;\n  }\n\n  derivative(delta: CalcMatrix2D): CalcMatrix2D {\n    return delta.multiply(-1).exp().add(1).fraction(1);\n  }\n}\n\nexport { SoftplusLayer };\n","import { AbstractLayer } from \"./AbstractLayer\";\nimport { Dimension, Layers } from \"../types\";\nimport { CalcMatrix2D } from \"../Math\";\n\nabstract class AbstractLayer3D extends AbstractLayer {\n  public W: CalcMatrix2D;\n  public b: CalcMatrix2D;\n  public A: CalcMatrix2D;\n  public Z: CalcMatrix2D;\n  public gW: CalcMatrix2D;\n  public gb: CalcMatrix2D;\n  public vW: CalcMatrix2D;\n  public sW: CalcMatrix2D;\n  public vb: CalcMatrix2D;\n  public sb: CalcMatrix2D;\n  public dW: CalcMatrix2D;\n  public db: CalcMatrix2D;\n  public dZ: CalcMatrix2D;\n\n  constructor() {\n    super();\n    this.W = new CalcMatrix2D();\n    this.b = new CalcMatrix2D();\n    this.A = new CalcMatrix2D();\n    this.Z = new CalcMatrix2D();\n    this.gW = new CalcMatrix2D();\n    this.gb = new CalcMatrix2D();\n    this.vW = new CalcMatrix2D();\n    this.vb = new CalcMatrix2D();\n    this.sW = new CalcMatrix2D();\n    this.sb = new CalcMatrix2D();\n    this.dW = new CalcMatrix2D();\n    this.db = new CalcMatrix2D();\n  }\n\n  configure(): void {\n    // do nothing\n  }\n\n  is1D(): boolean {\n    return false;\n  }\n\n  is3D(): boolean {\n    return true;\n  }\n\n  transition(previousLayer: Layers): Layers {\n    if (previousLayer.is3D()) {\n      this.setSize([previousLayer.getOutputWidth(), previousLayer.getOutputHeight(), previousLayer.getOutputDepth()]);\n    }\n\n    super.transition(previousLayer);\n\n    return this;\n  }\n\n  setSize(dimension: Dimension | number): Layers {\n    this.setWidth(dimension[0]);\n    this.setHeight(dimension[1]);\n    this.setDepth(dimension[2]);\n\n    return this;\n  }\n\n  getSize(): Dimension {\n    return [this.getWidth(), this.getHeight(), this.getDepth()];\n  }\n\n  abstract getPadding(): number;\n\n  abstract getStride(): number;\n\n  abstract getFilterSize(): number;\n\n  abstract forward(input: CalcMatrix2D): CalcMatrix2D;\n\n  abstract derivative(delta: CalcMatrix2D): CalcMatrix2D;\n\n  penalty(): number {\n    return this.W.pow(2).sum();\n  }\n}\n\nexport { AbstractLayer3D };\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer3D } from \"./AbstractLayer3D\";\n\n/**\n * Warstwa konwolucyjna (Convolutional Layer).\n * Przetwarza dane wejciowe 3D (wysoko, szeroko, gboko/kanay)\n * za pomoc zestawu filtrw, aby wyodrbni cechy takie jak krawdzie, tekstury itp.\n */\nexport class ConvLayer extends AbstractLayer3D {\n  protected numFilters = 8;\n  protected filterSize = 3;\n  protected padding = 1;\n  protected stride = 1;\n\n  // Pami podrczna dla wstecznej propagacji\n  private cache: {\n    inputCols?: CalcMatrix2D;\n    inputShape?: number[];\n  } = {};\n\n  public penalty(): number {\n    return this.W.pow(2).sum().get()[0];\n  }\n\n  configure(): void {\n    const inputDepth = this.getDepth();\n    const filterWeightCount = this.filterSize * this.filterSize * inputDepth;\n\n    this.W = new CalcMatrix2D(this.numFilters, filterWeightCount).setRandom(filterWeightCount);\n    this.b = new CalcMatrix2D(this.numFilters, 1).setZeros();\n\n    this.gW = new CalcMatrix2D(this.numFilters, filterWeightCount).setZeros();\n    this.gb = new CalcMatrix2D(this.numFilters, 1).setZeros();\n  }\n\n  getOutputHeight(): number {\n    return Math.floor((this.getHeight() - this.filterSize + 2 * this.padding) / this.stride + 1);\n  }\n\n  getOutputWidth(): number {\n    return Math.floor((this.getWidth() - this.filterSize + 2 * this.padding) / this.stride + 1);\n  }\n\n  getOutputDepth(): number {\n    return this.numFilters;\n  }\n\n  private im2col(input: CalcMatrix2D, batchSize: number): CalcMatrix2D {\n    const [inputHeight, inputWidth, inputDepth] = [this.getHeight(), this.getWidth(), this.getDepth()];\n    const outputHeight = this.getOutputHeight();\n    const outputWidth = this.getOutputWidth();\n    const filterArea = this.filterSize * this.filterSize;\n\n    const result = new CalcMatrix2D(filterArea * inputDepth, outputHeight * outputWidth * batchSize).allocate().calcSync((calc) => {\n      return calc.img2col(this.filterSize, this.stride, this.padding)\n    });\n    return result;\n  }\n\n  /**\n   * Przetwarza parti danych wejciowych.\n   * @param input Macierz o wymiarach (wysoko * szeroko * gboko, liczba_przykadw)\n   */\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    const batchSize = input.cols();\n    const outputHeight = this.getOutputHeight();\n    const outputWidth = this.getOutputWidth();\n\n    // 1. Przekszta wejcie za pomoc im2col\n    const inputCols = this.im2col(input, batchSize);\n    this.cache = { inputCols, inputShape: [this.getHeight(), this.getWidth(), this.getDepth()] };\n\n    // 2. Wykonaj operacj konwolucji jako jedno mnoenie macierzy\n    const result = this.W.dot(inputCols).add(this.b);\n\n    // 3. Przekszta wynik do odpowiedniego formatu wyjciowego\n    const reshapedResult = result.reshape(this.numFilters, outputHeight * outputWidth * batchSize);\n\n    // 4. Zastosuj funkcj aktywacji\n    this.Z = reshapedResult;\n    this.A = this.activation(this.Z);\n\n    return this.A;\n  }\n\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.relu(); // ReLU jest standardem dla warstw konwolucyjnych\n  }\n\n  derivative(delta: CalcMatrix2D): CalcMatrix2D {\n    return delta.reluDerivative(this.A);\n  }\n\n  getType(): LayerType {\n    return LayerType.conv;\n  }\n\n  // --- Settery dla parametrw warstwy ---\n  setFilterSize(size: number): this { this.filterSize = size; return this; }\n  setNumFilters(num: number): this { this.numFilters = num; return this; }\n  setPadding(pad: number): this { this.padding = pad; return this; }\n  setStride(stride: number): this { this.stride = stride; return this; }\n}\n","import { CalcMatrix2D } from \"../Math\";\nimport { Layers, LayerType } from \"../types\";\nimport { AbstractLayer1D } from \"./AbstractLayer1D\";\n\n/**\n * Warstwa w peni poczona (Fully Connected / Dense).\n * Kady neuron w tej warstwie jest poczony z kadym neuronem w warstwie poprzedniej.\n * Jest to podstawowy budulec wikszoci sieci neuronowych.\n */\nexport class FullyConnectedLayer extends AbstractLayer1D {\n  // Pami podrczna dla wstecznej propagacji\n  private cache: {\n    input?: CalcMatrix2D;\n  } = {};\n\n  public penalty(): number {\n    return this.W.pow(2).sum().get()[0];\n  }\n\n  /**\n   * Konfiguruje wagi i biasy warstwy.\n   * @param inputSize Rozmiar wektora wejciowego.\n   * @param outputSize Liczba neuronw w tej warstwie.\n   */\n  configure(inputSize: number, outputSize: number): void {\n    this.width = outputSize; // W kontekcie 1D, \"width\" to liczba neuronw\n    this.height = inputSize;\n\n    // Inicjalizacja wag (metoda Xavier)\n    this.W = new CalcMatrix2D(outputSize, inputSize).setRandom(inputSize);\n    // Inicjalizacja biasw\n    this.b = new CalcMatrix2D(outputSize, 1).setZeros();\n\n    // Inicjalizacja gradientw\n    this.gW = new CalcMatrix2D(outputSize, inputSize).setZeros();\n    this.gb = new CalcMatrix2D(outputSize, 1).setZeros();\n  }\n\n  /**\n   * Automatycznie konfiguruje rozmiar wejciowy na podstawie poprzedniej warstwy.\n   * Obsuguje \"spaszczanie\" (flattening) danych z warstw 3D.\n   */\n  transition(previousLayer: Layers): Layers {\n    this.previousLayer = previousLayer;\n    let inputSize: number;\n\n    if (previousLayer.is3D()) {\n      // Spaszczanie wyjcia z warstwy 3D (Conv, MaxPool)\n      inputSize = previousLayer.getOutputWidth() * previousLayer.getOutputHeight() * previousLayer.getOutputDepth();\n    } else {\n      // Standardowe poczenie z warstw 1D\n      inputSize = previousLayer.getOutputWidth();\n    }\n\n    // `this.width` jest ju ustawione w konstruktorze lub przez `setSize`\n    this.configure(inputSize, this.getWidth());\n    return this;\n  }\n\n  /**\n   * Przetwarza parti danych wejciowych.\n   * @param input Macierz o wymiarach (input_size, batch_size)\n   */\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    const batchSize = input.cols();\n    let currentInput = input;\n\n    // Jeli poprzednia warstwa bya 3D, spaszcz wejcie\n    if (this.previousLayer && this.previousLayer.is3D()) {\n      const inputSize = this.W.cols();\n      currentInput = input.reshape(inputSize, batchSize);\n    }\n\n    this.cache = { input: currentInput };\n\n    // Y = W * X + b\n    this.Z = this.W.dot(currentInput).add(this.b);\n    // W tej warstwie nie ma funkcji aktywacji.\n    // Aktywacj (np. ReLU, Softmax) naley doda jako osobn warstw.\n    this.A = this.Z;\n\n    return this.A;\n  }\n\n  // Ta warstwa nie ma wasnej funkcji aktywacji.\n  activation(m: CalcMatrix2D): CalcMatrix2D { return m; }\n  derivative(delta: CalcMatrix2D): CalcMatrix2D { return delta; }\n\n  getType(): LayerType {\n    return LayerType.fullyconnected;\n  }\n\n  setSize(value: number): this {\n    this.width = value;\n    return this;\n  }\n}\n","import { CalcMatrix2D } from \"../Math\";\nimport { LayerType } from \"../types\";\nimport { AbstractLayer3D } from \"./AbstractLayer3D\";\n\n/**\n * Warstwa Max-Pooling.\n * Redukuje wymiarowo przestrzenn (wysoko i szeroko) map cech,\n * zachowujc najwaniejsze informacje (maksymalne wartoci) z kadego regionu.\n */\nexport class MaxPoolLayer extends AbstractLayer3D {\n  protected filterSize = 2;\n  protected stride = 2;\n\n  // Pami podrczna dla wstecznej propagacji, przechowujca indeksy maksymalnych wartoci.\n  private cache: {\n    switches?: number[];\n    inputShape?: number[];\n  } = {};\n\n  // Warstwa Max-Pooling nie ma wag do uczenia si.\n  public penalty(): number { return 0; }\n  configure(): void { }\n  activation(m: CalcMatrix2D): CalcMatrix2D { return m; }\n  derivative(delta: CalcMatrix2D): CalcMatrix2D { return delta; }\n\n  getOutputHeight(): number {\n    return Math.floor((this.getHeight() - this.filterSize) / this.stride + 1);\n  }\n\n  getOutputWidth(): number {\n    return Math.floor((this.getWidth() - this.filterSize) / this.stride + 1);\n  }\n\n  getOutputDepth(): number {\n    return this.getDepth(); // Gboko pozostaje bez zmian\n  }\n\n  /**\n   * Przetwarza parti danych wejciowych.\n   * @param input Macierz o wymiarach (wysoko * szeroko * gboko, liczba_przykadw)\n   */\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    const batchSize = input.cols();\n    const [inputHeight, inputWidth, inputDepth] = [this.getHeight(), this.getWidth(), this.getDepth()];\n    const outputHeight = this.getOutputHeight();\n    const outputWidth = this.getOutputWidth();\n\n    const output = new CalcMatrix2D(outputHeight * outputWidth * inputDepth, batchSize).allocate().setZeros();\n    const switches: number[] = []; // Przechowuje indeksy maksymalnych wartoci\n\n    const inputData = input.get();\n    const outputData = output.get();\n\n    for (let n = 0; n < batchSize; n++) {\n      const batchOffset = n * inputHeight * inputWidth * inputDepth;\n      for (let c = 0; c < inputDepth; c++) {\n        const channelOffset = c * inputHeight * inputWidth;\n        for (let y = 0; y < outputHeight; y++) {\n          for (let x = 0; x < outputWidth; x++) {\n            const startY = y * this.stride;\n            const startX = x * this.stride;\n\n            let maxVal = -Infinity;\n            let maxIndex = -1;\n\n            // Znajd maksymaln warto w oknie\n            for (let fy = 0; fy < this.filterSize; fy++) {\n              for (let fx = 0; fx < this.filterSize; fx++) {\n                const imgY = startY + fy;\n                const imgX = startX + fx;\n                const currentIndex = batchOffset + channelOffset + imgY * inputWidth + imgX;\n                const currentVal = inputData[currentIndex];\n\n                if (currentVal > maxVal) {\n                  maxVal = currentVal;\n                  maxIndex = currentIndex;\n                }\n              }\n            }\n\n            // Zapisz maksymaln warto i jej indeks\n            const outputIndex = n * (outputHeight * outputWidth * inputDepth) + c * (outputHeight * outputWidth) + y * outputWidth + x;\n            outputData[outputIndex] = maxVal;\n            switches.push(maxIndex);\n          }\n        }\n      }\n    }\n    \n    output.set(outputData);\n    this.cache = { switches, inputShape: [inputHeight, inputWidth, inputDepth, batchSize] };\n    this.A = output;\n\n    return this.A;\n  }\n\n  getType(): LayerType {\n    return LayerType.maxpool;\n  }\n\n  // --- Settery dla parametrw warstwy ---\n  setFilterSize(size: number): this { this.filterSize = size; return this; }\n  getFilterSize(): number { return this.filterSize; }\n  setStride(stride: number): this { this.stride = stride; return this; }\n  getStride(): number { return this.stride; }\n  getPadding(): number { return 0; } // Max-pooling zazwyczaj nie uywa paddingu\n}\n","import { CalcMatrix2D } from \"../Math\";\nimport { Dimension, LayerType, Layers } from \"../types\";\nimport { AbstractLayer } from \"./AbstractLayer\";\n\n/**\n * Podstawowa warstwa rekurencyjna (RNN).\n * Ta warstwa przetwarza sekwencje danych, utrzymujc wewntrzny stan.\n *\n * Wymiary:\n * - `height` (inputSize): Rozmiar wektora wejciowego w jednym kroku czasowym.\n * - `width` (hiddenSize): Rozmiar wektora stanu ukrytego.\n * - `depth` (outputSize): Rozmiar wektora wyjciowego w jednym kroku czasowym.\n */\nexport class RecurrentLayer extends AbstractLayer {\n  activationAsync(value: CalcMatrix2D): Promise<CalcMatrix2D> {\n    throw new Error(\"Method not implemented.\");\n  }\n  // --- Wagi i Biary ---\n  public Wax: CalcMatrix2D; // Wagi: Wejcie -> Stan ukryty\n  public Waa: CalcMatrix2D; // Wagi: Stan ukryty -> Stan ukryty\n  public Wya: CalcMatrix2D; // Wagi: Stan ukryty -> Wyjcie\n\n  public ba: CalcMatrix2D; // Bias: Stan ukryty\n  public by: CalcMatrix2D; // Bias: Wyjcie\n\n  // --- Gradienty ---\n  public dWax: CalcMatrix2D;\n  public dWaa: CalcMatrix2D;\n  public dWya: CalcMatrix2D;\n  public dba: CalcMatrix2D;\n  public dby: CalcMatrix2D;\n\n  // --- Pami podrczna dla Backpropagation Through Time (BPTT) ---\n  public cache: {\n    A: CalcMatrix2D[]; // Stany ukryte a<t>\n    X: CalcMatrix2D[]; // Wejcia x<t>\n    Y?: CalcMatrix2D[]; // Wyjcia y<t>\n  } = { A: [], X: [] };\n\n  public penalty(): number {\n    // Prosta regularyzacja L2 dla wszystkich wag\n    const waaPenalty = this.Waa.pow(2).sum().get()[0];\n    const waxPenalty = this.Wax.pow(2).sum().get()[0];\n    const wyaPenalty = this.Wya.pow(2).sum().get()[0];\n    return waaPenalty + waxPenalty + wyaPenalty;\n  }\n\n  configure(): void {\n    const inputSize = this.getHeight();\n    const hiddenSize = this.getWidth();\n    const outputSize = this.getDepth();\n\n    // Inicjalizacja wag (metoda Xavier)\n    this.Wax = new CalcMatrix2D(hiddenSize, inputSize).setRandom(inputSize);\n    this.Waa = new CalcMatrix2D(hiddenSize, hiddenSize).setRandom(hiddenSize);\n    this.Wya = new CalcMatrix2D(outputSize, hiddenSize).setRandom(hiddenSize);\n\n    // Inicjalizacja biasw\n    this.ba = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    this.by = new CalcMatrix2D(outputSize, 1).setZeros();\n\n    // Inicjalizacja gradientw\n    this.dWax = new CalcMatrix2D(hiddenSize, inputSize).setZeros();\n    this.dWaa = new CalcMatrix2D(hiddenSize, hiddenSize).setZeros();\n    this.dWya = new CalcMatrix2D(outputSize, hiddenSize).setZeros();\n    this.dba = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    this.dby = new CalcMatrix2D(outputSize, 1).setZeros();\n  }\n\n  /**\n   * Przetwarza ca sekwencj wejciow.\n   * @param input Macierz o wymiarach (input_size, sequence_length)\n   */\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    const sequenceLength = input.cols();\n    const hiddenSize = this.getWidth();\n\n    // Inicjalizacja pamici podrcznej i stanu pocztkowego\n    this.cache = { A: [], X: [] };\n    let aPrev = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    this.cache.A.push(aPrev.clone());\n\n    const outputs: CalcMatrix2D[] = [];\n\n    // Ptla po krokach czasowych\n    for (let t = 0; t < sequenceLength; t++) {\n      const xt = input.col(t);\n      this.cache.X.push(xt.clone());\n\n      // Obliczenie stanu ukrytego: a<t> = tanh(Waa * a<t-1> + Wax * x<t> + ba)\n      const aNext = this.Waa.dot(aPrev).add(this.Wax.dot(xt)).add(this.ba).tanh();\n\n      // Obliczenie wyjcia: y<t> = Wya * a<t> + by (bez aktywacji)\n      const yt = this.Wya.dot(aNext).add(this.by);\n\n      outputs.push(yt);\n      this.cache.A.push(aNext);\n      aPrev = aNext;\n    }\n\n    // Pocz wszystkie wyjcia w jedn macierz\n    return CalcMatrix2D.hstack(outputs);\n  }\n\n  // --- Implementacja metod abstrakcyjnych ---\n\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    return m.tanh();\n  }\n\n  derivative(a: CalcMatrix2D): CalcMatrix2D {\n    // Pochodna tanh(x) to 1 - tanh(x)^2\n    return a.pow(2).minusOne().multiply(-1);\n  }\n\n  getType(): LayerType {\n    return LayerType.rnnlayer;\n  }\n\n  is1D(): boolean {\n    return true; // Traktujemy sekwencj jako \"pask\" warstw\n  }\n\n  is3D(): boolean {\n    return false;\n  }\n\n  transition(previousLayer: Layers): Layers {\n    this.previousLayer = previousLayer;\n    this.setHeight(previousLayer.getOutputHeight());\n    this.setDepth(this.getOutputHeight()); // Domylnie output_size = hidden_size\n    return this;\n  }\n\n  getSize(): number | Dimension {\n    return [this.getWidth(), this.getHeight(), this.getDepth()];\n  }\n\n  getOutputWidth(): number {\n    return this.getWidth();\n  }\n\n  getOutputHeight(): number {\n    return this.getDepth();\n  }\n\n  getOutputDepth(): number {\n    return 1;\n  }\n}\n","import { CalcMatrix2D } from \"../Math\";\nimport { Dimension, LayerType, Layers } from \"../types\";\nimport { AbstractLayer } from \"./AbstractLayer\";\n\n/**\n * Warstwa Long Short-Term Memory (LSTM).\n * Jest to zaawansowany typ warstwy rekurencyjnej, ktry potrafi uczy si\n * dugoterminowych zalenoci dziki mechanizmowi bramek.\n *\n * Wymiary:\n * - `height` (inputSize): Rozmiar wektora wejciowego w jednym kroku czasowym.\n * - `width` (hiddenSize): Rozmiar wektora stanu ukrytego i stanu komrki.\n */\nexport class LSTMLayer extends AbstractLayer {\n  // --- Wagi i Biary (zoptymalizowana, poczona struktura) ---\n  public W: CalcMatrix2D; // Poczone wagi dla wej [Wf, Wi, Wg, Wo]\n  public U: CalcMatrix2D; // Poczone wagi dla stanu rekurencyjnego [Uf, Ui, Ug, Uo]\n  public b: CalcMatrix2D; // Poczone biasy [bf, bi, bg, bo]\n\n  // --- Gradienty ---\n  public dW: CalcMatrix2D;\n  public dU: CalcMatrix2D;\n  public db: CalcMatrix2D;\n\n  // --- Pami podrczna dla BPTT ---\n  public cache: {\n    A: CalcMatrix2D[]; // Stany ukryte a<t>\n    C: CalcMatrix2D[]; // Stany komrki c<t>\n    X: CalcMatrix2D[]; // Wejcia x<t>\n    F: CalcMatrix2D[]; // Bramki zapominania f<t>\n    I: CalcMatrix2D[]; // Bramki wejciowe i<t>\n    G: CalcMatrix2D[]; // Bramki kandydujce g<t>\n    O: CalcMatrix2D[]; // Bramki wyjciowe o<t>\n  } = { A: [], C: [], X: [], F: [], I: [], G: [], O: [] };\n\n  public penalty(): number {\n    const wPenalty = this.W.pow(2).sum().get()[0];\n    const uPenalty = this.U.pow(2).sum().get()[0];\n    return wPenalty + uPenalty;\n  }\n\n  configure(): void {\n    const inputSize = this.getHeight();\n    const hiddenSize = this.getWidth();\n\n    // Inicjalizacja poczonych macierzy wag (metoda Xavier)\n    // Kada macierz ma wysoko 4 * hiddenSize, poniewa zawiera wagi dla 4 bramek.\n    this.W = new CalcMatrix2D(hiddenSize * 4, inputSize).setRandom(inputSize);\n    this.U = new CalcMatrix2D(hiddenSize * 4, hiddenSize).setRandom(hiddenSize);\n\n    // Inicjalizacja poczonego wektora biasw\n    this.b = new CalcMatrix2D(hiddenSize * 4, 1).setZeros();\n\n    // Inicjalizacja gradientw\n    this.dW = new CalcMatrix2D(hiddenSize * 4, inputSize).setZeros();\n    this.dU = new CalcMatrix2D(hiddenSize * 4, hiddenSize).setZeros();\n    this.db = new CalcMatrix2D(hiddenSize * 4, 1).setZeros();\n  }\n\n  /**\n   * Przetwarza ca sekwencj wejciow.\n   * @param input Macierz o wymiarach (input_size, sequence_length)\n   */\n  forward(input: CalcMatrix2D): CalcMatrix2D {\n    const sequenceLength = input.cols();\n    const hiddenSize = this.getWidth();\n\n    // Inicjalizacja pamici podrcznej i stanw pocztkowych\n    this.cache = { A: [], C: [], X: [], F: [], I: [], G: [], O: [] };\n    let aPrev = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    let cPrev = new CalcMatrix2D(hiddenSize, 1).setZeros();\n    this.cache.A.push(aPrev.clone());\n    this.cache.C.push(cPrev.clone());\n\n    const outputs: CalcMatrix2D[] = [];\n\n    // Ptla po krokach czasowych\n    for (let t = 0; t < sequenceLength; t++) {\n      const xt = input.col(t);\n      this.cache.X.push(xt.clone());\n\n      // 1. Oblicz aktywacje dla wszystkich bramek naraz (zoptymalizowane)\n      // Z = [Zf, Zi, Zg, Zo]^T\n      const Z = this.W.dot(xt).add(this.U.dot(aPrev)).add(this.b);\n\n      // 2. Podziel Z na poszczeglne bramki i zastosuj funkcje aktywacji\n      const Zf = Z.slice(0, hiddenSize);\n      const Zi = Z.slice(hiddenSize, hiddenSize * 2);\n      const Zg = Z.slice(hiddenSize * 2, hiddenSize * 3);\n      const Zo = Z.slice(hiddenSize * 3, hiddenSize * 4);\n\n      const ft = Zf.sigmoid(); // Bramka zapominania\n      const it = Zi.sigmoid(); // Bramka wejciowa\n      const gt = Zg.tanh();   // Bramka kandydujca\n      const ot = Zo.sigmoid(); // Bramka wyjciowa\n\n      // 3. Oblicz nowy stan komrki i nowy stan ukryty\n      // c<t> = f<t> * c<t-1> + i<t> * g<t>\n      const cNext = ft.multiply(cPrev).add(it.multiply(gt));\n      // a<t> = o<t> * tanh(c<t>)\n      const aNext = ot.multiply(cNext.tanh());\n\n      // 4. Zapisz wyniki w cache i zaktualizuj stany\n      outputs.push(aNext);\n      this.cache.A.push(aNext);\n      this.cache.C.push(cNext);\n      this.cache.F.push(ft);\n      this.cache.I.push(it);\n      this.cache.G.push(gt);\n      this.cache.O.push(ot);\n\n      aPrev = aNext;\n      cPrev = cNext;\n    }\n\n    // Pocz wszystkie wyjcia (stany ukryte) w jedn macierz\n    return CalcMatrix2D.hstack(outputs);\n  }\n\n  // --- Implementacja metod abstrakcyjnych ---\n\n  activation(m: CalcMatrix2D): CalcMatrix2D {\n    // Ta metoda nie jest bezporednio uywana w ptli forward,\n    // ale jest wymagana przez interfejs.\n    return m.tanh();\n  }\n\n  derivative(a: CalcMatrix2D): CalcMatrix2D {\n    // Pochodna tanh(x) to 1 - tanh(x)^2\n    return a.pow(2).minusOne();\n  }\n\n  getType(): LayerType {\n    return LayerType.lstm;\n  }\n\n  is1D(): boolean {\n    return true;\n  }\n\n  is3D(): boolean {\n    return false;\n  }\n\n  transition(previousLayer: Layers): Layers {\n    this.previousLayer = previousLayer;\n    this.setHeight(previousLayer.getOutputHeight());\n    this.setDepth(this.getOutputHeight());\n    return this;\n  }\n\n  getSize(): number | Dimension {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  getOutputWidth(): number {\n    return this.getWidth();\n  }\n\n  getOutputHeight(): number {\n    return this.getWidth(); // W LSTM rozmiar wyjcia jest rwny rozmiarowi stanu ukrytego\n  }\n\n  getOutputDepth(): number {\n    return 1;\n  }\n}\n","import { AbstractNetworkBuilder } from \"./AbstractNetworkBuilder\";\nimport { Layers } from \"../types\";\nimport { Network } from \"../Network\";\nimport * as fs from \"fs\";\nimport { LogisticLayer, ReluLayer, SoftmaxLayer, SoftplusLayer, TanhLayer } from \"../Layer/\";\nimport { CalcMatrix2D } from \"../Math\";\nimport { JSONLayerData } from \"./types\";\n\nclass NetworkBuilder1D extends AbstractNetworkBuilder {\n  firstLayerTransition(layer: Layers): void {\n    layer.setWidth(this.dimensions[0]);\n  }\n\n  static fromJSON(jsonPath: string): Promise<Network> {\n    return new Promise((resolve, reject) => {\n      fs.readFile(jsonPath, (err, data) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        const json = JSON.parse(data.toString());\n\n        const builder = new NetworkBuilder1D(json[\"dimensions\"]);\n\n        json[\"layers\"].forEach((layerData: JSONLayerData) => {\n          let layerClass = null;\n\n          if (layerData[\"type\"] === \"logistic\") {\n            layerClass = LogisticLayer;\n          } else if (layerData[\"type\"] === \"softmax\") {\n            layerClass = SoftmaxLayer;\n          } else if (layerData[\"type\"] === \"relu\") {\n            layerClass = ReluLayer;\n          } else if (layerData[\"type\"] === \"softplus\") {\n            layerClass = SoftplusLayer;\n          } else if (layerData[\"type\"] === \"tanh\") {\n            layerClass = TanhLayer;\n          }\n\n          builder.createLayer(layerClass, (layer) => {\n            // @ts-ignore\n            layer.setSize(layerData[\"size\"] as number);\n          });\n        });\n\n        const network = builder.getNetwork();\n\n        network.getLayers().forEach((layer, i) => {\n          layer.W = new CalcMatrix2D(\n            json[\"layers\"][i][\"weights\"][\"W\"].length,\n            json[\"layers\"][i][\"weights\"][\"W\"][0].length,\n            json[\"layers\"][i][\"weights\"][\"W\"]\n          );\n          layer.b = new CalcMatrix2D(\n            json[\"layers\"][i][\"weights\"][\"b\"].length,\n            json[\"layers\"][i][\"weights\"][\"b\"][0].length,\n            json[\"layers\"][i][\"weights\"][\"b\"]\n          );\n        });\n\n        resolve(network);\n      });\n    });\n  }\n}\n\nexport { NetworkBuilder1D };\n","import { AbstractNetworkBuilder } from \"./AbstractNetworkBuilder\";\nimport { Layers } from \"../types\";\nimport { Network } from \"../Network\";\nimport * as fs from \"fs\";\nimport { LogisticLayer, ReluLayer, SoftmaxLayer, SoftplusLayer, TanhLayer } from \"../Layer/\";\nimport { ConvLayer } from \"../Layer/\";\nimport { MaxPoolLayer } from \"../Layer/\";\nimport { JSONLayerData } from \"./types\";\n\nclass NetworkBuilder3D extends AbstractNetworkBuilder {\n  firstLayerTransition(layer: Layers): void {\n    if (this.dimensions) {\n      // @ts-ignore\n      layer.setSize(this.dimensions);\n    }\n  }\n\n  static fromJSON(jsonPath: string): Promise<Network> {\n    return new Promise((resolve, reject) => {\n      fs.readFile(jsonPath, (err, data) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        const json = JSON.parse(data.toString());\n\n        const builder = new NetworkBuilder3D(json[\"size\"]);\n\n        json[\"layers\"].forEach((layerData: JSONLayerData) => {\n          if (layerData[\"type\"] === \"logistic\") {\n            // @ts-ignore\n            builder.createLayer(LogisticLayer, (layer) => {\n              // @ts-ignore\n              layer.setSize(layerData[\"size\"]);\n            });\n          } else if (layerData[\"type\"] === \"softmax\") {\n            // @ts-ignore\n            builder.createLayer(SoftmaxLayer, (layer) => {\n              // @ts-ignore\n              layer.setSize(layerData[\"size\"]);\n            });\n          } else if (layerData[\"type\"] === \"relu\") {\n            // @ts-ignore\n            builder.createLayer(ReluLayer, (layer) => {\n              // @ts-ignore\n              layer.setSize(layerData[\"size\"]);\n            });\n          } else if (layerData[\"type\"] === \"softplus\") {\n            // @ts-ignore\n            builder.createLayer(SoftplusLayer, (layer) => {\n              // @ts-ignore\n              layer.setSize(layerData[\"size\"]);\n            });\n          } else if (layerData[\"type\"] === \"tanh\") {\n            // @ts-ignore\n            builder.createLayer(TanhLayer, (layer) => {\n              // @ts-ignore\n              layer.setSize(layerData[\"size\"]);\n            });\n          } else if (layerData[\"type\"] === \"conv\") {\n            // @ts-ignore\n            builder.createLayer(ConvLayer, (layer: ConvLayer) => {\n              layer.setSize(layerData[\"size\"]);\n              layer.setFilterSize(layerData[\"filterSize\"]);\n              layer.setStride(layerData[\"stride\"]);\n              layer.setNumFilters(layerData[\"numFilters\"]);\n              layer.setPadding(layerData[\"padding\"]);\n            });\n          } else if (layerData[\"type\"] === \"maxpool\") {\n            // @ts-ignore\n            builder.createLayer(MaxPoolLayer, (layer: MaxPoolLayer) => {\n              layer.setSize(layerData[\"size\"]);\n              layer.setFilterSize(layerData[\"filterSize\"]);\n              layer.setStride(layerData[\"stride\"]);\n            });\n          } else if (layerData[\"type\"] === \"fullyconnected\") {\n            // @ts-ignore\n            builder.createLayer(MaxPoolLayer);\n          }\n        });\n\n        const network = builder.getNetwork();\n\n        if (network) {\n          network.getLayers().forEach((layer, i) => {\n            layer.W = json[\"layers\"][\"W\"];\n            layer.b = json[\"layers\"][\"b\"];\n          });\n\n          resolve(network);\n        }\n      });\n    });\n  }\n}\n\nexport { NetworkBuilder3D };\n","import { Layers } from \"../../types\";\n\nexport abstract class AbstractOptimizer {\n  protected batchSize = 0;\n  protected t = 0;\n  protected learningRate = 0;\n\n  setBatchSize(batchSize: number): AbstractOptimizer {\n    this.batchSize = batchSize;\n    return this;\n  }\n\n  setT(t: number): AbstractOptimizer {\n    this.t = t;\n    return this;\n  }\n\n  setLearningRate(learningRate: number): AbstractOptimizer {\n    this.learningRate = learningRate;\n    return this;\n  }\n\n  abstract optimize(layer: Layers): void;\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\n\nexport class OptimizerAdam extends AbstractOptimizer {\n  protected beta1 = 0.9;\n  protected beta2 = 0.999;\n\n  setBeta1(beta1: number): OptimizerAdam {\n    this.beta1 = beta1;\n    return this;\n  }\n\n  setBeta2(beta2: number): OptimizerAdam {\n    this.beta2 = beta2;\n    return this;\n  }\n\n  optimize(layer: Layers): void {\n    this.adam(layer, this.learningRate, this.t);\n  }\n\n  adam(layer: Layers, learningRate: number, t: number): void {\n    layer.vW = layer.vW.multiply(this.beta1).add(layer.gW.multiply(1 - this.beta1));\n    layer.vb = layer.vb.multiply(this.beta1).add(layer.gb.multiply(1 - this.beta1));\n\n    layer.sW = layer.sW.multiply(this.beta2).add(layer.sW.pow(2).multiply(1 - this.beta2));\n    layer.sb = layer.sb.multiply(this.beta2).add(layer.sb.pow(2).multiply(1 - this.beta2));\n\n    const vWCorrected = layer.vW.divide(1 - Math.pow(this.beta1, 2));\n    const vbCorrected = layer.vb.divide(1 - Math.pow(this.beta1, 2));\n\n    const sWCorrected = layer.sW.add(1e-8).sqrt();\n    const sbCorrected = layer.sb.add(1e-8).sqrt();\n\n    layer.W = layer.W.subtract(vWCorrected.divide(sWCorrected).multiply(learningRate));\n    layer.b = layer.b.subtract(vbCorrected.divide(sbCorrected).multiply(learningRate));\n  }\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\n\nexport class OptimizerGradientDescent extends AbstractOptimizer {\n  optimize(layer: Layers): void {\n    this.gradientDescent(layer, this.learningRate);\n  }\n\n  gradientDescent(layer: Layers, learningRate: number): void {\n    layer.W = layer.W.subtract(layer.gW.multiply(learningRate));\n    layer.b = layer.b.subtract(layer.b.multiply(learningRate));\n  }\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\n\nexport class OptimizerAdagrad extends AbstractOptimizer {\n  private epsilon = 1e-8;\n\n  optimize(layer: Layers): void {\n    this.adagrad(layer, this.learningRate);\n  }\n\n  adagrad(layer: Layers, learningRate: number): void {\n    layer.dW = layer.dW.add(layer.gW.pow(2));\n    layer.W = layer.W.subtract(layer.gW.multiply(learningRate).divide(layer.dW.add(this.epsilon).sqrt()));\n\n    layer.db = layer.db.add(layer.gb.pow(2));\n    layer.b = layer.b.subtract(layer.gb.multiply(learningRate).divide(layer.db.add(this.epsilon).sqrt()));\n  }\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\n\nexport class OptimizerMomentum extends AbstractOptimizer {\n  protected beta = 0.9;\n\n  optimize(layer: Layers): void {\n    this.momentum(layer, this.learningRate);\n  }\n\n  setBeta(beta: number): OptimizerMomentum {\n    this.beta = beta;\n    return this;\n  }\n\n  momentum(layer: Layers, learningRate: number): void {\n    layer.vW = layer.gW.multiply(this.beta).add(layer.gW.multiply(1 - this.beta));\n    layer.vb = layer.gb.multiply(this.beta).add(layer.gb.multiply(1 - this.beta));\n\n    layer.W = layer.W.subtract(layer.vW.multiply(learningRate));\n    layer.b = layer.b.subtract(layer.vb.multiply(learningRate));\n  }\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\n\nexport class OptimizerRMSProp extends AbstractOptimizer {\n  protected alpha = 1e-3;\n  protected beta = 0.9;\n\n  setBeta(beta: number): OptimizerRMSProp {\n    this.beta = beta;\n    return this;\n  }\n\n  setAlpha(alpha: number): OptimizerRMSProp {\n    this.alpha = alpha;\n    return this;\n  }\n\n  optimize(layer: Layers): void {\n    this.rmsprop(layer, this.learningRate, this.alpha, this.beta);\n  }\n\n  rmsprop(layer: Layers, learningRate: number, alpha: number, beta: number): void {\n    layer.sW = layer.sW.multiply(beta).add(layer.gW.pow(2).multiply(1 - beta));\n    layer.sb = layer.sb.multiply(beta).add(layer.gb.pow(2).multiply(1 - beta));\n\n    layer.W = layer.W.subtract(layer.gW.multiply(alpha).divide(layer.sW.sqrt().add(1e-8)));\n    layer.b = layer.b.subtract(layer.gb.multiply(alpha).divide(layer.sb.sqrt().add(1e-8)));\n  }\n}\n","import { Network } from \"../Network\";\nimport { AbstractOptimizer } from \"./Optimizer/AbstractOptimizer\";\nimport { Dataset } from \"../Dataset\";\nimport { CalcMatrix2D } from \"../Math\";\nimport { AbstractCost } from \"./Cost/AbstractCost\";\n\nexport interface CostResult {\n  cost: number;\n  accuracy: number;\n}\n\nexport interface StepCallbackParameters {\n  iteration: number;\n}\n\nexport abstract class AbstractTrainer {\n  network: Network;\n  optimizer: AbstractOptimizer;\n  costFunction: AbstractCost;\n  regularization = 1e-4;\n  iterations = 1000;\n  learningRate = 0.001;\n  verbose = true;\n  verboseStep = 1;\n  stepCallback = (data: StepCallbackParameters): void => undefined;\n\n  constructor(network: Network, optimizer: AbstractOptimizer, costFunction: AbstractCost) {\n    this.network = network;\n    this.optimizer = optimizer;\n    this.costFunction = costFunction;\n  }\n\n  abstract train(inputDataset: Dataset, outputDataset: Dataset): AbstractTrainer;\n\n  setRegularization(regularization: number): AbstractTrainer {\n    this.regularization = regularization;\n    return this;\n  }\n\n  setIterations(iterations: number): AbstractTrainer {\n    this.iterations = iterations;\n    return this;\n  }\n\n  setLearningRate(learningRate: number): AbstractTrainer {\n    this.learningRate = learningRate;\n    return this\n  }\n\n  setVerbose(verbose: boolean): AbstractTrainer {\n    this.verbose = verbose;\n    return this;\n  }\n\n  setVerboseStep(verboseStep: number): AbstractTrainer {\n    this.verboseStep = verboseStep;\n    return this;\n  }\n\n  setStepCallback(stepCallback: (data: StepCallbackParameters) => void): AbstractTrainer {\n    this.stepCallback = stepCallback;\n    return this;\n  }\n\n  cost(predictions: CalcMatrix2D, correctOutput: CalcMatrix2D): CostResult {\n    const miniBatchSize = correctOutput.cols();\n    const dataLoss = this.costFunction.loss(correctOutput, predictions);\n\n    let regularizationPenalty = 0;\n    this.network.getLayers().forEach((layer) => {\n      regularizationPenalty += layer.penalty().get()[0];\n    });\n    const regularizationLoss = (this.regularization * regularizationPenalty) / (2.0 * miniBatchSize);\n\n    const cost = dataLoss + regularizationLoss;\n\n    let correctPredictions = 0;\n    for (let i = 0; i < miniBatchSize; i += 1) {\n      const predictionIndex = predictions.col(i).maxCoeff();\n      const outputIndex = correctOutput.col(i).maxCoeff();\n\n      if (predictionIndex.get()[0] === outputIndex.get()[0]) {\n        correctPredictions++;\n      }\n    }\n\n    const accuracy = (correctPredictions / miniBatchSize) * 100.0;\n\n    return {\n      cost,\n      accuracy,\n    };\n  }\n}\n","import { AbstractTrainer, CostResult } from \"./AbstractTrainer\";\n\nexport class MiniBatchTrainer extends AbstractTrainer {\n  /*batchSize = 100;\n\n  setBatchSize(batchSize: number): MiniBatchTrainer {\n    this.batchSize = batchSize;\n    return this;\n  }\n\n  cost(inputDataset: Dataset, outputDataset: Dataset): CostResult {\n    const batchSize = this.batchSize;\n    const numberOfExamples = inputDataset.getNumberOfExamples();\n    const numBatches = Math.ceil(numberOfExamples / batchSize);\n\n    let cost = 0.0;\n    let accuracy = 0.0;\n\n    // calculate penalty\n    let penalty = 0.0;\n\n    this.network.getLayers().forEach((layer) => {\n      penalty = layer.penalty();\n    });\n\n    const startTime = new Date().getTime();\n    const startIterationTime = new Date().getTime();\n\n    for (let batch = 0, offset = 0; batch < numberOfExamples; batch += this.batchSize, offset += this.batchSize) {\n      const startIterationTime2 = new Date().getTime();\n      const input = inputDataset.getBatch(offset, this.batchSize);\n      const correctOutput = outputDataset.getBatch(offset, this.batchSize);\n      const predictions = this.network.forward(input.data);\n\n      const error = correctOutput.data.multiply(predictions.log()).sum();\n      cost += (-1 / numberOfExamples) * error + this.regularization / (penalty * (2 * inputDataset.data.cols));\n\n      for (let col = 0; col < predictions.cols; col += 1) {\n        const index1 = predictions.colMaxCoeffIndex(col);\n        const index2 = correctOutput.data.colMaxCoeffIndex(col);\n\n        if (index1 === index2) {\n          accuracy++;\n        }\n      }\n    }\n\n    return {\n      cost,\n      accuracy: (accuracy / numberOfExamples) * 100,\n    };\n  }\n\n  train(inputDataset: Dataset, outputDataset: Dataset): MiniBatchTrainer {\n    const numberOfExamples = inputDataset.getNumberOfExamples();\n\n    let t = 0;\n\n    this.optimizer.setBatchSize(this.batchSize);\n    this.optimizer.setLearningRate(this.learningRate);\n\n    for (let i = 0; i < this.iterations; i += 1) {\n      const startTime = new Date().getTime();\n      const startIterationTime = new Date().getTime();\n\n      for (let batch = 0, offset = 0; batch < numberOfExamples; batch += this.batchSize, offset += this.batchSize) {\n        const startIterationTime2 = new Date().getTime();\n        const input = inputDataset.getBatch(offset, this.batchSize);\n        const output = outputDataset.getBatch(offset, this.batchSize);\n        const predictions = this.network.forward(input.data);\n\n        this.network.backward(input.data, output.data, this.regularization);\n\n        this.optimizer.setT(++t);\n\n        this.network.getLayers().forEach((layer) => {\n          this.optimizer.optimize(layer);\n        });\n\n        if (this.verbose) {\n          const cost = this.cost(input, output);\n          const endIterationTime = new Date().getTime();\n          console.log(\n            `Batch: ${offset} / ${numberOfExamples} | Batch time: ${\n              endIterationTime - startIterationTime2\n            }ms | Time from start: ${round((endIterationTime - startIterationTime) / 1000, 1)}s. | Cost: ${round(\n              cost.cost,\n              2\n            )} | Acc: ${cost.accuracy}`\n          );\n        }\n      }\n\n      if (this.verbose) {\n        if ((i + 1) % this.verboseStep === 0) {\n          const endTime = new Date().getTime();\n          const currentResult = this.cost(inputDataset, outputDataset);\n\n          console.log(\n            `Iteration: ${i + 1} | Cost: ${round(currentResult.cost, 5)} | Accuracy: ${\n              currentResult.accuracy\n            }% | Time: ${(endTime - startTime) / 1000} s.`\n          );\n        }\n      }\n\n      this.stepCallback({\n        iteration: i,\n      });\n    }\n\n    return this;\n  }*/\n}\n","import { AbstractTrainer } from \"./AbstractTrainer\";\nimport { Dataset } from \"../Dataset\";\nimport { round } from \"../Math\";\nimport { AbstractOptimizer } from \"./Optimizer/AbstractOptimizer\";\nimport { Network } from \"../Network\";\nimport { AbstractCost } from \"./Cost/AbstractCost\";\n\nexport class Trainer extends AbstractTrainer {\n  constructor(network: Network, optimizer: AbstractOptimizer, costFunction: AbstractCost) {\n    super(network, optimizer, costFunction);\n  }\n\n  train(inputDataset: Dataset, outputDataset: Dataset): AbstractTrainer {\n    const numberOfExamples = inputDataset.getNumberOfExamples();\n    const X = inputDataset.data.transpose();\n    const Y = outputDataset.data.transpose();\n\n    let t = 0;\n\n    this.optimizer.setBatchSize(numberOfExamples);\n    this.optimizer.setLearningRate(this.learningRate);\n\n    for (let i = 0; i < this.iterations; i += 1) {\n      const startTime = new Date().getTime();\n\n      const predictions = this.network.forward(X);\n\n      const sigma = this.costFunction.derivative(Y, predictions, this.network.getLastLayer());\n\n      this.network.backward(X, this.regularization, sigma);\n\n      this.optimizer.setT(++t);\n\n      this.network.getLayers().forEach((layer) => {\n        this.optimizer.optimize(layer);\n      });\n\n      if (this.verbose && (i + 1) % this.verboseStep === 0) {\n        const currentResult = this.cost(predictions, Y);\n        const endTime = new Date().getTime();\n\n        console.log(\n          `Iteration: ${i + 1} | Cost: ${round(currentResult.cost, 5)} | Accuracy: ${round(\n            currentResult.accuracy,\n            2\n          )}% | Time: ${(endTime - startTime) / 1000} s.`\n        );\n      }\n\n      this.stepCallback({\n        iteration: i,\n      });\n    }\n\n    return this;\n  }\n}\n","import { AbstractOptimizer } from \"./AbstractOptimizer\";\nimport { Layers } from \"../../types\";\nexport class OptimizerRNN extends AbstractOptimizer {\n  /*public hs = {};\n\n  public ys = {};\n\n  protected mWxh: Matrix = null;\n\n  protected mWhh: Matrix = null;\n\n  protected mWhy: Matrix = null;\n\n  protected mbh: Matrix = null;\n\n  protected mby: Matrix = null;\n\n  constructor(network: NetworkRNN) {\n    super();\n\n    this.mWxh = new Matrix(network.getDimensions()[0], network.getDimensions()[1]).setZeros();\n    this.mWhh = new Matrix(network.getDimensions()[0], network.getDimensions()[0]).setZeros();\n    this.mWhy = new Matrix(network.getDimensions()[1], network.getDimensions()[0]).setZeros();\n    this.mbh = new Matrix(network.getDimensions()[0], 1).setZeros();\n    this.mby = new Matrix(network.getDimensions()[1], 1).setZeros();\n  }\n  optimize(layer: Layers): void {\n    layer.dwX = layer.dwX.setMin(-5).setMax(5);\n    layer.dwY = layer.dwY.setMin(-5).setMax(5);\n    layer.dwA = layer.dwA.setMin(-5).setMax(5);\n    layer.dwB = layer.dwB.setMin(-5).setMax(5);\n    layer.dwBY = layer.dwBY.setMin(-5).setMax(5);\n\n    this.mWxh = this.mWxh.add(layer.dwX.pow(2));\n    layer.wX = layer.wX.add(layer.dwX.divide(this.mWxh.add(1e-8).sqrt()).multiply(-this.learningRate));\n\n    this.mWhh = this.mWhh.add(layer.dwA.pow(2));\n    layer.wA = layer.wA.add(layer.dwA.divide(this.mWhh.add(1e-8).sqrt()).multiply(-this.learningRate));\n\n    this.mWhy = this.mWhy.add(layer.dwY.pow(2));\n    layer.wY = layer.wY.add(layer.dwY.divide(this.mWhy.add(1e-8).sqrt()).multiply(-this.learningRate));\n\n    this.mbh = this.mbh.add(layer.dwB.pow(2));\n    layer.wB = layer.wB.add(layer.dwB.divide(this.mbh.add(1e-8).sqrt()).multiply(-this.learningRate));\n\n    this.mby = this.mby.add(layer.dwBY.pow(2));\n    layer.wBY = layer.wBY.add(layer.dwBY.divide(this.mby.add(1e-8).sqrt()).multiply(-this.learningRate));\n  }\n\n  setHS(hs: Matrix) {\n    this.hs[this.t] = hs;\n    return this;\n  }\n\n  setYS(ys: Matrix) {\n    this.ys[this.t] = ys;\n    return this;\n  }*/\n}\n","import { NetworkRNN } from \"../Network\";\nimport { DatasetVocabulary } from \"../Dataset/DatasetVocabulary\";\nimport { CalcMatrix2D } from \"../Math\";\nimport { OptimizerRNN } from \"./Optimizer/OptimizerRNN\";\n\nexport class RNNTrainer {\n  protected network: NetworkRNN | null = null;\n  protected iterations = 1000;\n  protected learningRate = 0.01;\n  protected optimizer: OptimizerRNN = null;\n\n  constructor(network: NetworkRNN) {\n    this.network = network;\n    this.optimizer = new OptimizerRNN(network).setLearningRate(this.learningRate);\n  }\n\n  train(dataset: DatasetVocabulary): [number] {\n    const [X, Y] = dataset.buildData(this.network.getDimensions()[0]);\n    const [x, y] = dataset.vectorization(X, Y);\n\n    //const hs = {};\n    //const ys = {};\n    this.optimizer\n      .setT(-1)\n      .setHS(new CalcMatrix2D(this.network.getDimensions()[0], this.network.getDimensions()[0]).setZeros());\n\n    /*let mWxh = new Matrix(this.network.getDimensions()[0], this.network.getDimensions()[1]).setZeros();\n    let mWhh = new Matrix(this.network.getDimensions()[0], this.network.getDimensions()[0]).setZeros();\n    let mWhy = new Matrix(this.network.getDimensions()[1], this.network.getDimensions()[0]).setZeros();\n    let mbh = new Matrix(this.network.layers[0].dwB.rows, this.network.layers[0].dwB.cols).setZeros();\n    let mby = new Matrix(this.network.layers[0].dwBY.rows, this.network.layers[0].dwBY.cols).setZeros();*/\n\n    for (let iteration = 0; iteration < this.iterations; iteration += 1) {\n      let _loss = 0;\n      for (let i = 0; i < X.length; i += 1) {\n        const { aNext, y: _y, loss } = this.network.forward(x[i], y[i], this.optimizer.hs[i - 1]);\n        this.optimizer.setT(i).setHS(aNext).setYS(_y);\n        //hs[i] = aNext;\n        //ys[i] = _y;\n\n        if ((i + 1) % 1000 === 0) {\n          console.log(`FORWARD Example ${i + 1} | Iteration ${iteration + 1}`);\n        }\n\n        _loss += loss;\n      }\n\n      console.log(`Loss ${_loss} | Iteration: ${iteration}`);\n\n      for (let i = X.length - 1; i >= 0; i -= 1) {\n        const dy = CalcMatrix2D.from(this.optimizer.ys[i].data);\n        for (let row = 0; row < dy.rows; row += 1) {\n          dy.data[row][x[i].transpose().rowMaxCoeffIndex(row)] -= 1;\n        }\n\n        this.network.backward(x[i], dy, this.optimizer.hs[i - 1], this.optimizer.hs[i]);\n\n        if ((i + 1) % 1000 === 0) {\n          console.log(`BACKWARD Example ${i + 1} | Iteration ${iteration + 1}`);\n        }\n      }\n\n      this.optimizer.optimize(this.network.layers[0]);\n\n      console.log(this.network.sample(dataset).trim());\n    }\n    return [0];\n  }\n\n  setIterations(num: number): RNNTrainer {\n    this.iterations = num;\n    return this;\n  }\n\n  setLearningRate(num: number): RNNTrainer {\n    this.learningRate = num;\n    this.optimizer.setLearningRate(num);\n    return this;\n  }\n}\n","import { CalcMatrix2D } from \"../../Math\";\n\nexport abstract class AbstractCost {\n  abstract loss(correctOutput: CalcMatrix2D, predictions: CalcMatrix2D): number;\n  abstract derivative(\n    correctOutput: CalcMatrix2D,\n    predictions: CalcMatrix2D,\n    activationDerivative: CalcMatrix2D\n  ): CalcMatrix2D;\n}\n","import { AbstractCost } from \"./AbstractCost\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { AbstractLayer } from \"../../Layer/AbstractLayer\";\n\nexport class MeanSquaredErrorCost extends AbstractCost {\n  loss(correctOutput: CalcMatrix2D, predictions: CalcMatrix2D): number {\n    const miniBatchSize = correctOutput.cols();\n    const error = predictions.subtract(correctOutput);\n    const cost = error.pow(2).sum().get()[0];\n    return cost / (2 * miniBatchSize);\n  }\n\n  derivative(\n    correctOutput: CalcMatrix2D,\n    predictions: CalcMatrix2D,\n    lastLayer: AbstractLayer\n  ): CalcMatrix2D {\n    const dA = predictions.subtract(correctOutput);\n    return dA.multiply(lastLayer.derivative(predictions));\n  }\n}\n","import { AbstractCost } from \"./AbstractCost\";\nimport { CalcMatrix2D } from \"../../Math\";\nimport { LayerType } from \"../../types\";\nimport { AbstractLayer } from \"../../Layer/AbstractLayer\";\n\nexport class CrossEntropyCost extends AbstractCost {\n  private readonly epsilon = 1e-8;\n\n  loss(correctOutput: CalcMatrix2D, predictions: CalcMatrix2D): number {\n    const miniBatchSize = correctOutput.cols();\n    const logPredictions = predictions.add(this.epsilon).log();\n    const cost = correctOutput.multiply(logPredictions).sum().get()[0];\n    return -cost / miniBatchSize;\n  }\n\n  derivative(\n    correctOutput: CalcMatrix2D,\n    predictions: CalcMatrix2D,\n    lastLayer: AbstractLayer\n  ): CalcMatrix2D {\n    if (lastLayer.getType() === LayerType.softmax) {\n      return predictions.subtract(correctOutput);\n    }\n\n    const denominator = predictions\n      .multiply(predictions.minusOne().multiply(-1))\n      .add(this.epsilon);\n\n    const dA = predictions.subtract(correctOutput).divide(denominator);\n\n    return dA.multiply(lastLayer.derivative(predictions));\n  }\n}\n","import { CalcMatrix2D } from \"../Math/CalcMatrix2D\";\n\nexport class Dataset {\n  public exampleSize = 0;\n  public numberOfExamples = 0;\n  public data: CalcMatrix2D | null = null;\n\n  constructor(exampleSize: number = null, numberOfExamples: number = null, data: CalcMatrix2D = null) {\n    this.exampleSize = exampleSize;\n    this.numberOfExamples = numberOfExamples;\n\n    if (data) {\n      this.data = data;\n    }\n  }\n\n  static fromMatrix(m: CalcMatrix2D): Dataset {\n    const instance = new Dataset();\n    instance.exampleSize = m.rows;\n    instance.numberOfExamples = m.cols;\n    instance.data = m;\n\n    return instance;\n  }\n\n  exampleAt(index: number): CalcMatrix2D | null {\n    return this.data.row(index).transpose();\n  }\n\n  getNumberOfExamples(): number {\n    return this.data.rows();\n  }\n\n  getExampleSize(): number {\n    return this.data.cols();\n  }\n\n  getBatch(offset: number, batchSize: number): Dataset {\n    const data = this.data.block(0, offset, this.data.rows, batchSize);\n    return Dataset.fromMatrix(data);\n  }\n\n  /*insertColumnAfter(column, size = 1) {\n    const oldData = this.data.copy();\n\n    this.exampleSize = this.data.rows + size;\n    this.data.resize(this.data.rows + size, this.data.cols);\n\n    for (let row = 0; row < this.data.rows; row += 1) {\n      for (let col = 0; col < this.data.cols; col += 1) {\n        if (row <= column) {\n          this.data.data[row][col] = oldData.data[row][col];\n        } else if (row > column && row <= column + size) {\n          this.data.data[row][col] = undefined;\n        } else if (row > column + size) {\n          this.data.data[row][col] = oldData.data[row - size][col];\n        }\n      }\n    }\n  }*/\n}\n","import { Dataset } from \"../Dataset\";\nimport { AbstractDatasetBuilderSource } from \"./DatasetBuilderSource/AbstractDatasetBuilderSource\";\n\ninterface ParametersInterface {\n  transpose?: boolean;\n}\n\nexport class DatasetBuilder {\n  static fromSource(\n    sourcePromise: Promise<AbstractDatasetBuilderSource>,\n    params: ParametersInterface = {}\n  ): Promise<Dataset> {\n    return new Promise((resolve) => {\n      sourcePromise.then((source) => {\n        const matrix = source.parse();\n        const numberOfExamples = matrix.rows();\n        const exampleSize = matrix.cols();\n\n        const dataset = new Dataset(exampleSize, numberOfExamples, matrix);\n        resolve(dataset);\n      });\n    });\n  }\n}\n","import { CalcMatrix2D } from \"../Math/CalcMatrix2D\";\n\nexport class DatasetVocabulary {\n  /*public vocabularySize = 0;\npublic dataSize = 0;\npublic data: string = \"\";\npublic chars: string[];\n\nconstructor(str: string) {\n  this.data = str.toLowerCase();\n  const chars = [...new Set(this.data.split(\"\").sort())];\n\n  this.chars = chars;\n  this.dataSize = this.data.length;\n  this.vocabularySize = chars.length;\n}\n\ngetExamples(): string[] {\n  return this.data\n    .replace(/\\n+/, \"\\n\")\n    .split(\"\\n\")\n    .map((example: string) => {\n      return example + \"\\n\";\n    });\n}\n\ngetVocabularySize(): number {\n  return this.vocabularySize;\n}\n\ngetCharsLength(): number {\n  return this.chars.length;\n}\n\ngetCharIndices(): Object {\n  const result = {};\n  this.chars.forEach((char, i) => {\n    result[char] = i;\n  });\n  return result;\n}\n\nbuildData(tx: number = 40, stride: number = 3) {\n  const X = [];\n  const Y = [];\n\n  for (let i = 0; i < this.data.length - tx; i += stride) {\n    X.push(this.data.substr(i, tx));\n    Y.push(this.data[i + tx]);\n  }\n\n  return [X, Y];\n}\n\nvectorization(X: string[], Y: string[], nx: number = 40): [Matrix[], Matrix] {\n  const m = X.length;\n  const x = new Array(m);\n  const chars = this.getCharIndices();\n  const y = new Matrix(m, this.chars.length).setZeros();\n  let xIndex = 0;\n  let rowIndex = 0;\n\n  X.forEach((sentence: string, _m) => {\n    x[_m] = new Matrix(sentence.length, this.chars.length).setZeros();\n    sentence.split(\"\").forEach((char, t) => {\n      x[_m].data[t][chars[char]] = 1;\n      rowIndex++;\n    });\n    xIndex++;\n    rowIndex = 0;\n\n    y.data[_m][chars[Y[_m]]] = 1;\n  });\n\n  return [x, y];\n}\n\ngetChars(): string[] {\n  return this.chars;\n}\n\ngetExampleX(exampleIndex: number): Matrix {\n  const example = this.getExamples()[exampleIndex];\n  const data = [];\n  example.split(\"\").forEach((ch, row) => {\n    data[row] = [this.getCharIndices()[ch]];\n  });\n  return Matrix.from(data);\n}\n\ngetExampleY(exampleIndex: number): Matrix {\n  const example = this.getExamples()[exampleIndex];\n  const data = [];\n  example.split(\"\").forEach((ch, row) => {\n    data[row] = [this.getCharIndices()[ch]];\n  });\n  return Matrix.from(data);\n}*/\n}\n","import { AbstractDatasetVocabularyBuilderSource } from \"./DatasetVocabularyBuilderSource/AbstractDatasetVocabularyBuilderSource\";\nimport { DatasetVocabulary } from \"../Dataset/DatasetVocabulary\";\n\nexport class DatasetVocabularyBuilder {\n  static fromSource(sourcePromise: Promise<AbstractDatasetVocabularyBuilderSource>): Promise<DatasetVocabulary> {\n    return new Promise((resolve) => {\n      sourcePromise.then((source) => {\n        const str = source.parse();\n        resolve(new DatasetVocabulary(str));\n      });\n    });\n  }\n}\n","import { CalcMatrix2D } from \"../../Math/CalcMatrix2D\";\n\nexport abstract class AbstractDatasetBuilderSource {\n  abstract parse(): CalcMatrix2D;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"csvtojson\");","import { AbstractDatasetBuilderSource } from \"./AbstractDatasetBuilderSource\";\nimport { CalcMatrix2D } from \"../../Math/CalcMatrix2D\";\nimport * as csvtojson from \"csvtojson\";\n\n/*enum CSVState {\n  UnquotedField,\n  QuotedField,\n  QuotedQuote,\n}*/\n\nexport class DatasetBuilderSourceCSV extends AbstractDatasetBuilderSource {\n  protected data: number[][] | string[][] | null = null;\n  protected matrixData: number[][] | string[][] = null;\n\n  constructor(data: number[][] | string[][]) {\n    super();\n    this.data = data;\n  }\n\n  static fromLocalFile(path: string): Promise<DatasetBuilderSourceCSV> {\n    /*return new Promise((resolve, reject) => {\n      fs.readFile(path, (err, buffer) => {\n        console.log(\"first\");\n        if (err) {\n          console.log(err);\n          reject();\n        } else {\n          const instance = new DatasetBuilderSourceCSV(buffer.toString(\"utf-8\"));\n          resolve(instance);\n        }\n      });\n    });*/\n    return new Promise((resolve) => {\n      csvtojson({\n        noheader: true,\n        output: \"csv\",\n      })\n        .fromFile(path)\n        .then((arr) => {\n          resolve(new DatasetBuilderSourceCSV(arr));\n        });\n    });\n  }\n\n  parse(): CalcMatrix2D {\n    const numberOfExamples = this.data.length;\n    const exampleSize = this.data[0]?.length;\n\n    if (typeof numberOfExamples !== \"undefined\" && typeof exampleSize !== \"undefined\") {\n      let data = [];\n      for (let i = 0; i < numberOfExamples; i += 1) {\n        const newData = [];\n        this.data[i].forEach((value, index) => {\n          newData.push(Number(value));\n        });\n        data = [...data, ...newData];\n      }\n      return new CalcMatrix2D(numberOfExamples, exampleSize).allocate().set(new Float64Array(data));\n    }\n\n    return new CalcMatrix2D(0, 0);\n  }\n  /*\n  protected parseLine(line: string, exampleIndexCol: number): void {\n    let state = CSVState.UnquotedField;\n    const fields = [];\n    let i = 0;\n\n    for (let j = 0; j < line.length; j += 1) {\n      const c = line.at(j);\n      switch (state) {\n        case CSVState.UnquotedField:\n          switch (c) {\n            case \",\": // end of field\n              fields.push(\"\");\n              i++;\n              break;\n            case '\"':\n              state = CSVState.QuotedField;\n              break;\n            default:\n              fields[i] += c;\n              break;\n          }\n          break;\n        case CSVState.QuotedField:\n          switch (c) {\n            case '\"':\n              state = CSVState.QuotedQuote;\n              break;\n            default:\n              fields[i] += c;\n              break;\n          }\n          break;\n        case CSVState.QuotedQuote:\n          switch (c) {\n            case \",\": // , after closing quote\n              fields.push(\"\");\n              i++;\n              state = CSVState.UnquotedField;\n              break;\n            case '\"': // \"\" -> \"\n              fields[i] += '\"';\n              state = CSVState.QuotedField;\n              break;\n            default:\n              // end of quote\n              state = CSVState.UnquotedField;\n              break;\n          }\n          break;\n      }\n\n      fields.forEach((value, row) => {\n        if (value.length === 0) {\n          value = NaN;\n        }\n        value = parseFloat(value);\n        if (!this.matrixData[row]) {\n          this.matrixData[row] = [];\n        }\n        this.matrixData[row][exampleIndexCol] = value;\n      });\n    }\n  }*/\n}\n","import * as fs from \"fs\";\nimport { AbstractDatasetVocabularyBuilderSource } from \"./AbstractDatasetVocabularyBuilderSource\";\n\nexport class DatasetVocabularyBuilderSourceTextFile extends AbstractDatasetVocabularyBuilderSource {\n  protected data: string = \"\";\n\n  constructor(data: string) {\n    super();\n    this.data = data;\n  }\n\n  static fromLocalFile(path: string): Promise<DatasetVocabularyBuilderSourceTextFile> {\n    return new Promise((resolve, reject) => {\n      fs.readFile(path, (err, buffer) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(new DatasetVocabularyBuilderSourceTextFile(buffer.toString(\"utf-8\")));\n      });\n    });\n  }\n\n  parse(): string {\n    return this.data;\n  }\n}\n","export abstract class AbstractDatasetVocabularyBuilderSource {\n  abstract parse(): string;\n}\n","import { Dataset } from \"../Dataset\";\n\nexport abstract class AbstractDatasetModifier {\n  protected dataset: Dataset = null;\n\n  constructor(dataset: Dataset) {\n    this.dataset = dataset;\n  }\n\n  abstract apply(dataset: Dataset): Dataset | Array<Dataset>;\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { CalcMatrix2D } from \"../../Math/CalcMatrix2D\";\nimport { Dataset } from \"../Dataset\";\n\nexport class CallbackDatasetModifier extends AbstractDatasetModifier {\n  /*protected callback: (example: CalcMatrix2D) => CalcMatrix2D = (example) => example;\n\n  apply(): Dataset {\n    for (let exampleIndex = 0; exampleIndex < this.dataset.getNumberOfExamples(); exampleIndex += 1) {\n      const example = this.callback(this.dataset.exampleAt(exampleIndex));\n      for (let row = 0; row < this.dataset.data.rows; row += 1) {\n        if (example) {\n          this.dataset.data.data[row][exampleIndex] = example.data[row][0];\n        }\n      }\n    }\n    return this.dataset;\n  }\n\n  setCallback(callback: (example: Matrix2D) => Matrix2D): CallbackDatasetModifier {\n    this.callback = callback;\n    return this;\n  }*/\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { Dataset } from \"../Dataset\";\n\nexport class MinMaxScalingDatasetModifier extends AbstractDatasetModifier {\n  apply(dataset: Dataset): Dataset {\n    const newData = dataset.data.minMax();\n    dataset.data = newData;\n    return dataset;\n  }\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { Dataset } from \"../Dataset\";\n\nexport class MissingDataDatasetModifier extends AbstractDatasetModifier {\n  protected modificationType = \"mean\";\n\n  apply(dataset: Dataset): Dataset {\n    const rowsToFill = [];\n    let correctExamplesCount = 0;\n    let sum = 0;\n    let valueToFill = 0;\n\n    for (let exampleIndex = 0; exampleIndex < dataset.getNumberOfExamples(); exampleIndex += 1) {\n      const example = dataset.exampleAt(exampleIndex);\n      for (let row = 0; row < dataset.getExampleSize(); row += 1) {\n        if (isNaN(example.data[row][0]) || typeof example.data[row][0] !== \"number\") {\n          rowsToFill.push({\n            row,\n            col: example,\n          });\n        } else {\n          sum += example.data[row][0];\n          correctExamplesCount++;\n        }\n      }\n    }\n\n    if (this.modificationType === \"mean\") {\n      valueToFill = sum / correctExamplesCount;\n    }\n\n    rowsToFill.forEach(({ row, col }) => {\n      dataset.data.data[row][col] = valueToFill;\n    });\n\n    return dataset;\n  }\n\n  setModificationType(type: string): MissingDataDatasetModifier {\n    this.modificationType = type;\n    return this;\n  }\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { Dataset } from \"../Dataset\";\nimport { CalcMatrix2D } from \"../../Math/CalcMatrix2D\";\n\nexport class ShuffleDatasetModifier extends AbstractDatasetModifier {\n  /*public sortList: number[] = [];\n\n  constructor(dataset: Dataset) {\n    super(dataset);\n  }\n\n  apply(dataset: Dataset): Dataset {\n    return dataset;\n    let index = 0;\n    const data = Matrix.from(\n      dataset.data.transpose().data.sort((exampleA: number[], exampleB: number[]) => {\n        if (typeof this.sortList[index] === \"undefined\") {\n          // first run\n          this.sortList[index] = Math.random() - 0.5;\n        }\n        index += 1;\n        return this.sortList[index - 1];\n      })\n    ).transpose().data;\n    return new Dataset(dataset.getExampleSize(), dataset.getNumberOfExamples(), data);\n}*/\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { Dataset } from \"../Dataset\";\n\nexport class CategoryDatasetModifier extends AbstractDatasetModifier {\n  protected columns: Array<number>;\n\n  constructor(columns: Array<number>) {\n    super(null);\n    this.columns = columns;\n  }\n\n  apply(dataset: Dataset): Dataset {\n    let size = 0;\n    let _dataset = dataset;\n\n    this.columns.sort().forEach((column) => {\n      let [dataset, _size] = this.applyForColumn(_dataset, column + size);\n      // @ts-ignore\n      size += _size;\n      _dataset = dataset;\n    });\n    return dataset;\n  }\n\n  applyForColumn(dataset: Dataset, column: number): [Dataset, number] {\n    const example = dataset.data.row(column);\n    let values = [];\n\n    for (let row = 0; row < example.rows; row += 1) {\n      values.push(example.value(row, 0));\n    }\n\n    values = values.filter((value, index, self) => {\n      return self.indexOf(value) === index;\n    });\n\n    dataset.insertColumnAfter(column, values.length - 1);\n\n    for (let col = 0; col < dataset.data.cols; col += 1) {\n      const oldValue = dataset.data.data[column][col];\n      let index = 0;\n      for (let row = 0; row < dataset.data.rows; row += 1) {\n        if (row >= column && row < column + values.length) {\n          if (index === values.indexOf(oldValue)) {\n            dataset.data.data[row][col] = 1;\n          } else {\n            dataset.data.data[row][col] = 0;\n          }\n          index += 1;\n        }\n      }\n    }\n\n    return [dataset, values.length - 1];\n  }\n}\n","import { AbstractDatasetModifier } from \"./AbstractDatasetModifier\";\nimport { Dataset } from \"../Dataset\";\nimport { CalcMatrix2D } from \"../../Math/CalcMatrix2D\";\n\nexport class SplitDatasetModifier extends AbstractDatasetModifier {\n  /*protected columns: Array<number>;\n\n  constructor(columns: Array<number>) {\n    super(null);\n    this.columns = columns.sort();\n  }\n\n  apply(dataset: Dataset): Array<Dataset> {\n    return [];\n    /*const inputData = [];\n    const outputData = [];\n\n    for (let col = 0; col < dataset.getNumberOfExamples(); col += 1) {\n      const example = dataset.exampleAt(col);\n      for (let row = 0, _inputIndex = 0, _outputIndex = 0; row < dataset.exampleSize; row += 1) {\n        if (this.columns.includes(row)) {\n          if (!inputData[_inputIndex]) {\n            inputData[_inputIndex] = [];\n          }\n          inputData[_inputIndex][col] = example.data[row][0];\n          _inputIndex += 1;\n        } else {\n          if (!outputData[_outputIndex]) {\n            outputData[_outputIndex] = [];\n          }\n          outputData[_outputIndex][col] = example.data[row][0];\n          _outputIndex += 1;\n        }\n      }\n    }\n\n    const newInputData = Matrix.from(inputData).transpose().data;\n    const newOutputData = Matrix.from(outputData).transpose().data;\n\n    const inputDataset = new Dataset(newInputData[0].length, newInputData.length, newInputData);\n    const outputDataset = new Dataset(newOutputData[0].length, newOutputData.length, newOutputData);\n\n    return [inputDataset, outputDataset];\n}*/\n}\n","import { CalcScalar } from \"./Math/CalcScalar\";\nimport { CalcRowVector } from \"./Math/CalcRowVector\";\nimport { CalcColVector } from \"./Math/CalcColVector\";\nimport { CalcMatrix2D } from \"./Math/CalcMatrix2D\";\nimport { CalcMatrix3D } from \"./Math/CalcMatrix3D\";\nimport { setDevice, getDevice } from \"./Computation\";\nimport { NetworkBuilder1D, NetworkBuilder3D } from \"./NetworkBuilder\";\nimport {\n  SoftmaxLayer,\n  LogisticLayer,\n  ReluLayer,\n  SoftplusLayer,\n  TanhLayer,\n  ConvLayer,\n  FullyConnectedLayer,\n  MaxPoolLayer,\n  RecurrentLayer,\n  LSTMLayer,\n} from \"./Layer\";\nimport {\n  OptimizerAdam,\n  OptimizerGradientDescent,\n  OptimizerAdagrad,\n  OptimizerMomentum,\n  OptimizerRMSProp,\n} from \"./Trainer/Optimizer\";\nimport { MiniBatchTrainer, Trainer as TrainerTrainer, RNNTrainer } from \"./Trainer\";\nimport { NetworkRNN, NetworkLSTM } from \"./Network\";\nimport { MeanSquaredErrorCost} from \"./Trainer/Cost/MeanSquaredErrorCost\";\nimport { CrossEntropyCost } from \"./Trainer/Cost/CrossEntropyCost\";\n\nconst NetworkBuilder = { NetworkBuilder1D, NetworkBuilder3D };\nconst Layer = {\n  SoftmaxLayer,\n  LogisticLayer,\n  ReluLayer,\n  SoftplusLayer,\n  TanhLayer,\n  ConvLayer,\n  MaxPoolLayer,\n  FullyConnectedLayer,\n  RecurrentLayer,\n  LSTMLayer,\n};\nconst Optimizer = {\n  OptimizerAdam,\n  OptimizerGradientDescent,\n  OptimizerAdagrad,\n  OptimizerMomentum,\n  OptimizerRMSProp,\n};\nconst Trainer = {\n  MiniBatchTrainer,\n  Trainer: TrainerTrainer,\n  RNNTrainer,\n};\nconst Network = {\n  NetworkRNN,\n  NetworkLSTM,\n};\n\nconst Cost = {\n  MeanSquaredErrorCost, CrossEntropyCost\n}\n\nimport native from \"../../build/Release/node_native_memory.node\";\nimport path from \"path\";\n\nnative.setModulePath(path.resolve(__dirname, \"../\"));\n\nimport { Dataset as DatasetDataset } from \"./Dataset\";\nimport { DatasetBuilder as DatasetBuilderBuilder, DatasetVocabularyBuilder } from \"./DatasetBuilder\";\nimport { DatasetBuilderSourceCSV } from \"./DatasetBuilder/DatasetBuilderSource\";\nimport { DatasetVocabularyBuilderSourceTextFile } from \"./DatasetBuilder/DatasetVocabularyBuilderSource\";\n\nimport {\n  CallbackDatasetModifier,\n  MinMaxScalingDatasetModifier,\n  MissingDataDatasetModifier,\n  ShuffleDatasetModifier,\n  CategoryDatasetModifier,\n  SplitDatasetModifier,\n} from \"./Dataset/DatasetModifier\";\n\nconst DatasetBuilder = {\n  DatasetBuilder: DatasetBuilderBuilder,\n  DatasetVocabularyBuilder,\n};\nconst Dataset = {\n  Dataset: DatasetDataset,\n};\nconst DatasetModifier = {\n  CallbackDatasetModifier,\n  MinMaxScalingDatasetModifier,\n  MissingDataDatasetModifier,\n  ShuffleDatasetModifier,\n  CategoryDatasetModifier,\n  SplitDatasetModifier,\n};\nconst DatasetBuilderSource = {\n  DatasetBuilderSourceCSV,\n  DatasetVocabularyBuilderSourceTextFile,\n};\nconst Math = {\n  CalcScalar, CalcRowVector, CalcColVector, CalcMatrix2D, CalcMatrix3D, setDevice, getDevice, native\n}\n\nexport { NetworkBuilder, Layer, Optimizer, Trainer, Network, Cost, Math, DatasetBuilder, Dataset, DatasetModifier, DatasetBuilderSource };\nexport default { NetworkBuilder, Layer, Optimizer, Trainer, Network, Cost,Math, DatasetBuilder, Dataset, DatasetModifier, DatasetBuilderSource  };\n"],"names":["process","dlopen","module","__dirname","error","Error","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","id","loaded","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","nmd","paths","children","p","currentDevice","nodenative","CPU","getDevice","Calc","_classCallCheck","_defineProperty","result","this","_result","params","_params","kernel","exec","_this","Promise","resolve","then","async","arguments","length","fn","loadModule","loadFunction","input","output","execute","map","m","getMemory","e","console","CalcElement","width","height","depth","_dims","_this$_dims","_slicedToArray","allocate","device","_memory","alloc","count","setWidth","rows","setHeight","cols","setDepth","_allocated","arr","set","Float64Array","calcSync","calc","setZeros","number","setRandom","setMax","setMin","reluBackpropagation","pow","sum","reluForwardPropagation","that","CalcScalar","_call","nb","setResult","setParams","execAsync","execSync","callback","getCalcSandbox","reject","dispose","free","other","copyFrom","dims","_CalcElement","_callSuper","_inherits","CalcColVector","memory","CalcRowVector","fromMemory","clone","CalcMatrix2D","index","maxCoeff","dot","add","replicate","transpose","logisticForwardPropagation","logisticBackwardPropagation","log","multiply","minusOne","conjugate","mOrNumber","divide","subtract","rowwiseSum","softmax","num","fraction","tanh","tanhDerivative","logMinusOne","sqrt","offset","batch","start","end","block","softmaxDerivative","min","max","minMax","baseSandbox","_objectSpread","_offset","_batch","_start","_end","_m","__rows","__cols","img2col","filterSize","stride","padding","CalcMatrix3D","Network","dimensions","layer","size","layers","push","forEach","forward","l","next","forwardAsync","out","destroy","X","regularization","sigma","currentSigma","i","getBackPropagation","propagate","path","resultJSON","type","getType","getSize","weights","W","b","JSON","stringify","fs","err","NetworkRNN","_createClass","NetworkLSTM","LayerType","AbstractBackPropagation","previousLayer","round","decimalPlaces","Math","Backpropagation1Dto1D","_AbstractBackPropagat","numberOfExamples","previousActivations","A","delta","gW","gb","concat","derivative","Backpropagation3Dto1D","BackpropagationToMaxPool","_maxPoolLayer$cache","cache","switches","_inputShape","inputShape","inputHeight","inputWidth","inputDepth","batchSize","dX","dXData","sigmaData","switchIndex","outputSize","reshape","BackpropagationToConv","BackpropagationToRecurrent","rnnLayer","_rnnLayer$cache","sequenceLength","daNext","getWidth","t","dyt","col","dWya","dby","dtanh","Wya","dWax","dWaa","dba","Waa","_i","_arr","clip","Wax","BackpropagationToLSTM","lstmLayer","_lstmLayer$cache","C","F","I","G","O","hiddenSize","dcNext","da","dZo","dc","dZf","dZi","dZg","dZ","vstack","dW","dU","db","U","BackpropagationFactory","rnnlayer","lstm","maxpool","conv","is1D","fullyconnected","is3D","AbstractNetworkBuilder","dimension","network","layerClass","lastLayer","firstLayerTransition","transition","configure","setBackPropagation","create","addLayer","AbstractLayer","backPropagation","AbstractLayer1D","_AbstractLayer","Z","vW","vb","sW","sb","resize","getHeight","activation","_this2","all","calcAsync","_ref","_ref2","added","activationAsync","getOutputWidth","getOutputHeight","getOutputDepth","SoftmaxLayer","_AbstractLayer1D","LogisticLayer","logistic","TanhLayer","ReluLayer","relu","SoftplusLayer","exp","softplus","AbstractLayer3D","setSize","getDepth","ConvLayer","_AbstractLayer3D","_len","args","Array","_key","filterWeightCount","numFilters","floor","outputHeight","outputWidth","filterArea","inputCols","im2col","reshapedResult","reluDerivative","pad","FullyConnectedLayer","inputSize","currentInput","MaxPoolLayer","inputData","outputData","batchOffset","c","channelOffset","y","x","startY","startX","maxVal","maxIndex","fy","fx","currentIndex","currentVal","RecurrentLayer","ba","by","aPrev","outputs","xt","aNext","yt","hstack","LSTMLayer","cPrev","Zf","slice","Zi","Zg","Zo","ft","sigmoid","it","gt","ot","cNext","NetworkBuilder1D","_AbstractNetworkBuild","jsonPath","data","json","parse","toString","builder","layerData","createLayer","getNetwork","getLayers","NetworkBuilder3D","setFilterSize","setStride","setNumFilters","setPadding","AbstractOptimizer","learningRate","OptimizerAdam","_AbstractOptimizer","beta1","beta2","adam","vWCorrected","vbCorrected","sWCorrected","sbCorrected","OptimizerGradientDescent","gradientDescent","OptimizerAdagrad","adagrad","epsilon","OptimizerMomentum","momentum","beta","OptimizerRMSProp","alpha","rmsprop","AbstractTrainer","optimizer","costFunction","iterations","verbose","verboseStep","stepCallback","predictions","correctOutput","miniBatchSize","dataLoss","loss","regularizationPenalty","penalty","cost","correctPredictions","predictionIndex","outputIndex","accuracy","MiniBatchTrainer","_AbstractTrainer","Trainer","inputDataset","outputDataset","getNumberOfExamples","Y","setBatchSize","setLearningRate","startTime","Date","getTime","getLastLayer","backward","setT","optimize","currentResult","endTime","iteration","OptimizerRNN","RNNTrainer","dataset","_dataset$buildData2","buildData","getDimensions","_dataset$vectorizatio2","vectorization","setHS","_loss","_this$network$forward","hs","_y","setYS","dy","from","ys","row","rowMaxCoeffIndex","sample","trim","AbstractCost","MeanSquaredErrorCost","_AbstractCost","CrossEntropyCost","logPredictions","denominator","Dataset","exampleSize","instance","fromMatrix","DatasetBuilder","sourcePromise","source","matrix","DatasetVocabulary","DatasetVocabularyBuilder","str","AbstractDatasetBuilderSource","DatasetBuilderSourceCSV","_AbstractDatasetBuild","csvtojson","noheader","fromFile","_this$data$","_loop","newData","Number","_toConsumableArray","DatasetVocabularyBuilderSourceTextFile","_AbstractDatasetVocab","buffer","AbstractDatasetVocabularyBuilderSource","AbstractDatasetModifier","CallbackDatasetModifier","_AbstractDatasetModif","MinMaxScalingDatasetModifier","MissingDataDatasetModifier","rowsToFill","correctExamplesCount","valueToFill","exampleIndex","example","exampleAt","getExampleSize","isNaN","modificationType","ShuffleDatasetModifier","CategoryDatasetModifier","columns","_dataset","sort","column","_this2$applyForColumn2","applyForColumn","_size","values","filter","self","indexOf","insertColumnAfter","oldValue","SplitDatasetModifier","NetworkBuilder","Layer","Optimizer","TrainerTrainer","Cost","native","DatasetBuilderBuilder","DatasetDataset","DatasetModifier","DatasetBuilderSource","setDevice"],"sourceRoot":""}